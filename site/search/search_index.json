{"config":{"lang":["fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Go Starter Kit","text":"<p>Un outil CLI puissant pour generer des projets Go prets pour la production en quelques secondes.</p>"},{"location":"#demarrage-rapide","title":"Demarrage rapide","text":"<p> Installation - Installez et creez votre premier projet en 30 secondes</p> <p> Guide d'utilisation - Structure de projet avec separation claire des responsabilites</p> <p> Projet genere - JWT, Docker, CI/CD, tests et plus inclus par defaut</p> <p> Contribuer - Contribuez au projet et ameliorez l'ecosysteme Go</p>"},{"location":"#apercu","title":"Apercu","text":"<p><code>create-go-starter</code> est un generateur de projets Go qui cree une architecture hexagonale complete avec toutes les fonctionnalites essentielles d'une application backend moderne. En une seule commande, obtenez un projet structure avec authentification JWT, API REST, base de donnees, tests, et configuration Docker prete pour le deploiement.</p>"},{"location":"#fonctionnalites-incluses","title":"Fonctionnalites incluses","text":"Fonctionnalite Description Architecture hexagonale Ports &amp; Adapters - Separation claire des responsabilites Authentification JWT Access tokens + Refresh tokens avec rotation securisee API REST Framework Fiber v2 haute performance Base de donnees GORM avec PostgreSQL et migrations automatiques Injection de dependances uber-go/fx pour une architecture modulaire Tests complets Tests unitaires et d'integration inclus Documentation Swagger API documentee automatiquement avec OpenAPI Docker Build multi-stage optimise et docker-compose CI/CD Pipeline GitHub Actions pre-configure Logging structure rs/zerolog pour des logs professionnels"},{"location":"#installation-rapide","title":"Installation rapide","text":"go install (Recommande)Build depuis sources <pre><code>go install github.com/tky0065/go-starter-kit/cmd/create-go-starter@latest\n</code></pre> <pre><code>git clone https://github.com/tky0065/go-starter-kit.git\ncd go-starter-kit\ngo build -o create-go-starter ./cmd/create-go-starter\n</code></pre>"},{"location":"#demarrage-en-30-secondes","title":"Demarrage en 30 secondes","text":"<pre><code># 1. Installer l'outil\ngo install github.com/tky0065/go-starter-kit/cmd/create-go-starter@latest\n\n# 2. Creer un projet\ncreate-go-starter mon-projet\n\n# 3. Configuration automatique\ncd mon-projet\n./setup.sh\n\n# 4. Lancer\nmake run\n\n# 5. Tester\ncurl http://localhost:8080/health\n</code></pre>"},{"location":"#structure-generee","title":"Structure generee","text":"<pre><code>mon-projet/\n\u251c\u2500\u2500 cmd/\n\u2502   \u2514\u2500\u2500 main.go                    # Point d'entree avec fx\n\u251c\u2500\u2500 internal/\n\u2502   \u251c\u2500\u2500 models/                    # Entites de domaine\n\u2502   \u251c\u2500\u2500 domain/                    # Logique metier\n\u2502   \u251c\u2500\u2500 adapters/                  # HTTP handlers, repositories\n\u2502   \u2502   \u251c\u2500\u2500 handlers/\n\u2502   \u2502   \u251c\u2500\u2500 middleware/\n\u2502   \u2502   \u2514\u2500\u2500 repository/\n\u2502   \u251c\u2500\u2500 infrastructure/            # Database, server config\n\u2502   \u2514\u2500\u2500 interfaces/                # Ports (interfaces)\n\u251c\u2500\u2500 pkg/                           # Packages reutilisables\n\u2502   \u251c\u2500\u2500 auth/                      # JWT utilities\n\u2502   \u251c\u2500\u2500 config/                    # Configuration\n\u2502   \u2514\u2500\u2500 logger/                    # Logging\n\u251c\u2500\u2500 .github/workflows/ci.yml       # CI/CD\n\u251c\u2500\u2500 Dockerfile                     # Build optimise\n\u251c\u2500\u2500 Makefile                       # Commandes utiles\n\u2514\u2500\u2500 go.mod\n</code></pre>"},{"location":"#stack-technique","title":"Stack technique","text":"<p>Les projets generes utilisent les meilleures bibliotheques de l'ecosysteme Go :</p> Composant Bibliotheque Description Web Fiber v2 Framework HTTP haute performance ORM GORM ORM avec support PostgreSQL DI fx Injection de dependances par Uber Logging zerolog Logger structure haute performance JWT golang-jwt v5 Tokens JWT Validation validator v10 Validation de structs"},{"location":"#architecture","title":"Architecture","text":"<pre><code>graph TB\n    subgraph Adapters\n        HTTP[HTTP Handlers]\n        REPO[Repository GORM]\n    end\n\n    subgraph Domain\n        SVC[Services]\n        ENT[Entities]\n    end\n\n    subgraph Infrastructure\n        DB[(PostgreSQL)]\n        CFG[Config]\n    end\n\n    HTTP --&gt; SVC\n    SVC --&gt; ENT\n    SVC --&gt; REPO\n    REPO --&gt; DB\n    CFG --&gt; SVC</code></pre>"},{"location":"#prochaines-etapes","title":"Prochaines etapes","text":"<ul> <li> Installation - Guide d'installation detaille</li> <li> Utilisation - Apprendre a utiliser le CLI</li> <li> Architecture - Comprendre le fonctionnement interne</li> <li> Tutoriel - Exemple complet pas a pas</li> </ul> <p>Fait avec  pour la communaute Go</p>"},{"location":"cli-architecture/","title":"Architecture de l'outil CLI","text":"<p>Documentation technique pour contributeurs et d\u00e9veloppeurs avanc\u00e9s.</p>"},{"location":"cli-architecture/#vue-densemble","title":"Vue d'ensemble","text":"<p><code>create-go-starter</code> est un g\u00e9n\u00e9rateur de projets Go qui cr\u00e9e des applications compl\u00e8tes avec architecture hexagonale, authentification JWT, API REST, et infrastructure de d\u00e9ploiement.</p> <pre><code>create-go-starter (CLI)\n\u251c\u2500\u2500 main.go              # Entry point, validation, orchestration\n\u251c\u2500\u2500 generator.go         # File generation orchestrator\n\u251c\u2500\u2500 templates.go         # Core templates (config, server, domain)\n\u2514\u2500\u2500 templates_user.go    # User domain specific templates\n</code></pre> <p>Statistiques: - Lignes de code: ~4,500+ - Fichiers g\u00e9n\u00e9r\u00e9s par projet: 46+ - Templates: 31+ fonctions - D\u00e9pendances: Standard library uniquement</p>"},{"location":"cli-architecture/#composants-principaux","title":"Composants principaux","text":""},{"location":"cli-architecture/#1-maingo-point-dentree","title":"1. main.go - Point d'entr\u00e9e","text":"<p>Responsabilit\u00e9s: - Parsing des arguments CLI (package <code>flag</code>) - Validation du nom de projet (regex alphanumeric + hyphens/underscores) - Cr\u00e9ation de la structure de r\u00e9pertoires - Orchestration de la g\u00e9n\u00e9ration de fichiers - Gestion des erreurs et affichage console (avec couleurs)</p> <p>Fonctions cl\u00e9s:</p> <pre><code>func main()\nfunc validateProjectName(name string) error\nfunc createProjectStructure(projectName string) error\nfunc copyEnvFile(projectPath string) error\nfunc printSuccess(projectName string)\n</code></pre> <p>Flux d'ex\u00e9cution:</p> <pre><code>1. Parse command-line arguments (flag.Parse)\n2. Validate project name (alphanumeric + - _)\n3. Check if directory already exists\n4. Create project directory\n5. Create subdirectory structure (cmd/, internal/, pkg/, etc.)\n6. Generate all files via generateProjectFiles()\n7. Copy .env.example \u2192 .env\n8. Print success message with next steps\n</code></pre> <p>Validation du nom:</p> <pre><code>// Regex pattern\nvar validProjectName = regexp.MustCompile(`^[a-zA-Z0-9][a-zA-Z0-9_-]*$`)\n\n// Valid: mon-projet, my-api, user_service, app2024\n// Invalid: -projet, mon projet, my.project, @app\n</code></pre> <p>Messages color\u00e9s:</p> <pre><code>func Green(text string) string\nfunc Red(text string) string\n\n// Usage\nfmt.Println(Green(\"\u2713 Project created successfully!\"))\nfmt.Println(Red(\"\u2717 Error: \" + err.Error()))\n</code></pre>"},{"location":"cli-architecture/#2-generatorgo-orchestrateur-de-generation","title":"2. generator.go - Orchestrateur de g\u00e9n\u00e9ration","text":"<p>Responsabilit\u00e9s: - Validation du r\u00e9pertoire projet - Validation du module name Go (compatible go.mod) - Cr\u00e9ation de tous les fichiers du projet - Gestion des templates avec injection du nom de projet</p> <p>Structure FileGenerator:</p> <pre><code>type FileGenerator struct {\n    Path    string  // Chemin relatif au projet (ex: cmd/main.go)\n    Content string  // Contenu g\u00e9n\u00e9r\u00e9 du fichier\n}\n</code></pre> <p>Fonction principale:</p> <pre><code>func generateProjectFiles(projectPath, projectName string) error {\n    // Validate project directory exists\n    // Validate Go module name\n    // Create templates instance\n    templates := NewProjectTemplates(projectName)\n\n    // Define all files\n    files := []FileGenerator{\n        {Path: \"go.mod\", Content: templates.GoModTemplate()},\n        {Path: \"cmd/main.go\", Content: templates.MainGoTemplate()},\n        // ... 40+ more files\n    }\n\n    // Write all files\n    for _, file := range files {\n        os.MkdirAll(filepath.Dir(file.Path), 0755)\n        os.WriteFile(file.Path, []byte(file.Content), 0644)\n    }\n\n    return nil\n}\n</code></pre> <p>Liste compl\u00e8te des fichiers g\u00e9n\u00e9r\u00e9s (45+ fichiers):</p> <ol> <li>Configuration (6 fichiers):</li> <li>go.mod, .env.example, .gitignore, .golangci.yml</li> <li> <p>Makefile, docker-compose.yml</p> </li> <li> <p>Bootstrap (1 fichier):</p> </li> <li> <p>cmd/main.go</p> </li> <li> <p>Packages r\u00e9utilisables (7 fichiers):</p> </li> <li>pkg/config/env.go, pkg/config/module.go</li> <li>pkg/logger/logger.go, pkg/logger/module.go</li> <li> <p>pkg/auth/jwt.go, pkg/auth/middleware.go, pkg/auth/module.go</p> </li> <li> <p>Models (1 fichier):</p> </li> <li> <p>internal/models/user.go (User, RefreshToken, AuthResponse)</p> </li> <li> <p>Domain (3 fichiers):</p> </li> <li>internal/domain/errors.go</li> <li>internal/domain/user/service.go</li> <li> <p>internal/domain/user/module.go</p> </li> <li> <p>Interfaces (1 fichier):</p> </li> <li> <p>internal/interfaces/user_repository.go</p> </li> <li> <p>Adapters (10 fichiers):</p> </li> <li>Handlers: auth_handler.go, user_handler.go, module.go</li> <li>Middleware: error_handler.go</li> <li>Repository: user_repository.go, module.go</li> <li> <p>HTTP: health.go, routes.go</p> </li> <li> <p>Infrastructure (2 fichiers):</p> </li> <li>internal/infrastructure/database/database.go</li> <li> <p>internal/infrastructure/server/server.go</p> </li> <li> <p>Deployment (3 fichiers):</p> </li> <li>Dockerfile</li> <li>.github/workflows/ci.yml</li> <li> <p>docker-compose.yml</p> </li> <li> <p>Documentation (3 fichiers):</p> </li> <li>README.md</li> <li>docs/README.md</li> <li>docs/quick-start.md</li> </ol> <p>Validation Go module name:</p> <pre><code>func validateGoModuleName(name string) error {\n    // Must start with letter/number\n    // Only alphanumeric, hyphens, underscores\n    // No spaces, special chars\n    pattern := regexp.MustCompile(`^[a-zA-Z0-9][a-zA-Z0-9_-]*$`)\n    return pattern.MatchString(name)\n}\n</code></pre>"},{"location":"cli-architecture/#3-templatesgo-templates-principaux","title":"3. templates.go - Templates principaux","text":"<p>Responsabilit\u00e9s: - D\u00e9finition des templates pour infrastructure et configuration - Templates: configuration, server, database, middleware, Docker, CI/CD - Injection dynamique du nom de projet</p> <p>Structure ProjectTemplates:</p> <pre><code>type ProjectTemplates struct {\n    projectName string\n}\n\nfunc NewProjectTemplates(projectName string) *ProjectTemplates {\n    return &amp;ProjectTemplates{projectName: projectName}\n}\n</code></pre> <p>M\u00e9thodes principales (30+ templates):</p>"},{"location":"cli-architecture/#configuration-build","title":"Configuration &amp; Build","text":"<pre><code>func (t *ProjectTemplates) GoModTemplate() string\nfunc (t *ProjectTemplates) MakefileTemplate() string\nfunc (t *ProjectTemplates) DockerfileTemplate() string\nfunc (t *ProjectTemplates) DockerComposeTemplate() string\nfunc (t *ProjectTemplates) GolangCILintTemplate() string\nfunc (t *ProjectTemplates) GitHubActionsWorkflowTemplate() string\nfunc (t *ProjectTemplates) EnvTemplate() string\nfunc (t *ProjectTemplates) GitignoreTemplate() string\n</code></pre>"},{"location":"cli-architecture/#bootstrap","title":"Bootstrap","text":"<pre><code>func (t *ProjectTemplates) UpdatedMainGoTemplate() string // fx.New bootstrap\n</code></pre>"},{"location":"cli-architecture/#packages-pkg","title":"Packages (pkg/)","text":"<pre><code>func (t *ProjectTemplates) ConfigTemplate() string          // pkg/config/env.go\nfunc (t *ProjectTemplates) LoggerTemplate() string          // pkg/logger/logger.go\nfunc (t *ProjectTemplates) JWTAuthTemplate() string         // pkg/auth/jwt.go\nfunc (t *ProjectTemplates) JWTMiddlewareTemplate() string   // pkg/auth/middleware.go\nfunc (t *ProjectTemplates) AuthModuleTemplate() string      // pkg/auth/module.go\n</code></pre>"},{"location":"cli-architecture/#infrastructure","title":"Infrastructure","text":"<pre><code>func (t *ProjectTemplates) DatabaseTemplate() string        // database.go\nfunc (t *ProjectTemplates) ServerTemplate() string          // server.go avec Fiber\n</code></pre>"},{"location":"cli-architecture/#middleware","title":"Middleware","text":"<pre><code>func (t *ProjectTemplates) ErrorHandlerMiddlewareTemplate() string\n</code></pre>"},{"location":"cli-architecture/#health-check-routes","title":"Health Check &amp; Routes","text":"<pre><code>func (t *ProjectTemplates) HealthHandlerTemplate() string    // health.go\nfunc (t *ProjectTemplates) RoutesTemplate() string           // routes.go - Centralized routes\n</code></pre>"},{"location":"cli-architecture/#documentation","title":"Documentation","text":"<pre><code>func (t *ProjectTemplates) ReadmeTemplate() string\nfunc (t *ProjectTemplates) DocsReadmeTemplate() string      // docs/README.md\nfunc (t *ProjectTemplates) QuickStartTemplate() string      // docs/quick-start.md\n</code></pre>"},{"location":"cli-architecture/#setup-automation","title":"Setup &amp; Automation","text":"<pre><code>func (t *ProjectTemplates) SetupScriptTemplate() string     // setup.sh - Automated setup\n</code></pre> <p>SetupScriptTemplate g\u00e9n\u00e8re un script bash interactif qui: - V\u00e9rifie les pr\u00e9requis (Go, OpenSSL, Docker, psql) - Installe les d\u00e9pendances (<code>go mod tidy</code>) - G\u00e9n\u00e8re et configure le JWT secret dans <code>.env</code> - Configure PostgreSQL (Docker ou local) - Ex\u00e9cute les tests de validation - V\u00e9rifie l'installation compl\u00e8te</p> <p>Le script est rendu ex\u00e9cutable automatiquement (<code>chmod 0755</code>) par <code>generator.go</code>.</p> <p>Pattern de template:</p> <p>Les templates utilisent la concat\u00e9nation de strings (pas de text/template):</p> <pre><code>func (t *ProjectTemplates) GoModTemplate() string {\n    return `module ` + t.projectName + `\n\ngo 1.25.5\n\nrequire (\n    github.com/gofiber/fiber/v2 v2.52.10\n    // ...\n)\n`\n}\n</code></pre> <p>Avantages: - Simplicit\u00e9 (pas de parsing) - Type-safe \u00e0 la compilation - Facile \u00e0 d\u00e9bugger - Injection directe du projectName</p> <p>Inconv\u00e9nients: - Verbeux pour templates complexes - \u00c9chappement manuel des backticks</p>"},{"location":"cli-architecture/#4-templates_usergo-templates-du-domaine-user","title":"4. templates_user.go - Templates du domaine User","text":"<p>Responsabilit\u00e9s: - Templates sp\u00e9cifiques au domaine User - Entit\u00e9s (models), services, repositories, handlers - Tests (si impl\u00e9ment\u00e9)</p> <p>M\u00e9thodes:</p>"},{"location":"cli-architecture/#models-entites-partagees","title":"Models (Entit\u00e9s partag\u00e9es)","text":"<pre><code>func (t *ProjectTemplates) ModelsUserTemplate() string  // User, RefreshToken, AuthResponse\n</code></pre>"},{"location":"cli-architecture/#domain","title":"Domain","text":"<pre><code>func (t *ProjectTemplates) DomainErrorsTemplate() string\nfunc (t *ProjectTemplates) UserServiceTemplate() string   // Business logic\nfunc (t *ProjectTemplates) UserModuleTemplate() string    // fx module\n</code></pre> <p>Note: <code>UserEntityTemplate()</code> et <code>UserRefreshTokenTemplate()</code> sont d\u00e9pr\u00e9ci\u00e9s - les entit\u00e9s sont maintenant dans <code>ModelsUserTemplate()</code>.</p>"},{"location":"cli-architecture/#interfaces-ports","title":"Interfaces (Ports)","text":"<pre><code>func (t *ProjectTemplates) UserInterfacesTemplate() string\nfunc (t *ProjectTemplates) UserRepositoryInterfaceTemplate() string\n</code></pre>"},{"location":"cli-architecture/#adapters","title":"Adapters","text":"<pre><code>func (t *ProjectTemplates) UserRepositoryTemplate() string  // GORM implementation\nfunc (t *ProjectTemplates) RepositoryModuleTemplate() string\nfunc (t *ProjectTemplates) AuthHandlerTemplate() string     // Register, Login, Refresh\nfunc (t *ProjectTemplates) UserHandlerTemplate() string     // CRUD endpoints\nfunc (t *ProjectTemplates) HandlerModuleTemplate() string\n</code></pre> <p>Contenu typique d'un template (exemple: ModelsUserTemplate):</p> <pre><code>func (t *ProjectTemplates) ModelsUserTemplate() string {\n    return `package models\n\nimport (\n    \"time\"\n    \"gorm.io/gorm\"\n)\n\n// User represents the domain entity for a user\ntype User struct {\n    ID           uint           ` + \"`gorm:\\\"primaryKey\\\" json:\\\"id\\\"`\" + `\n    Email        string         ` + \"`gorm:\\\"uniqueIndex;not null\\\" json:\\\"email\\\"`\" + `\n    PasswordHash string         ` + \"`gorm:\\\"not null\\\" json:\\\"-\\\"`\" + `\n    CreatedAt    time.Time      ` + \"`gorm:\\\"autoCreateTime\\\" json:\\\"created_at\\\"`\" + `\n    UpdatedAt    time.Time      ` + \"`gorm:\\\"autoUpdateTime\\\" json:\\\"updated_at\\\"`\" + `\n    DeletedAt    gorm.DeletedAt ` + \"`gorm:\\\"index\\\" json:\\\"deleted_at,omitempty\\\"`\" + `\n}\n\n// RefreshToken represents a refresh token for session management\ntype RefreshToken struct {\n    ID        uint      ` + \"`gorm:\\\"primaryKey\\\" json:\\\"id\\\"`\" + `\n    UserID    uint      ` + \"`gorm:\\\"not null;index\\\" json:\\\"user_id\\\"`\" + `\n    Token     string    ` + \"`gorm:\\\"uniqueIndex;not null\\\" json:\\\"token\\\"`\" + `\n    ExpiresAt time.Time ` + \"`gorm:\\\"not null\\\" json:\\\"expires_at\\\"`\" + `\n    Revoked   bool      ` + \"`gorm:\\\"not null;default:false\\\" json:\\\"revoked\\\"`\" + `\n    CreatedAt time.Time ` + \"`gorm:\\\"autoCreateTime\\\" json:\\\"created_at\\\"`\" + `\n    UpdatedAt time.Time ` + \"`gorm:\\\"autoUpdateTime\\\" json:\\\"updated_at\\\"`\" + `\n}\n\nfunc (rt *RefreshToken) IsExpired() bool {\n    return time.Now().After(rt.ExpiresAt)\n}\n\nfunc (rt *RefreshToken) IsRevoked() bool {\n    return rt.Revoked\n}\n\n// AuthResponse represents the authentication response with tokens\ntype AuthResponse struct {\n    AccessToken  string ` + \"`json:\\\"access_token\\\"`\" + `\n    RefreshToken string ` + \"`json:\\\"refresh_token\\\"`\" + `\n    ExpiresIn    int64  ` + \"`json:\\\"expires_in\\\"`\" + `\n}\n`\n}\n</code></pre> <p>Pourquoi <code>models</code> au lieu de <code>domain/user</code>? - \u00c9vite les d\u00e9pendances circulaires: Les interfaces peuvent r\u00e9f\u00e9rencer les mod\u00e8les sans cr\u00e9er de cycles - Centralisation: Les entit\u00e9s sont d\u00e9finies en un seul endroit - R\u00e9utilisabilit\u00e9: Tous les layers (domain, interfaces, adapters) peuvent importer models sans conflit</p>"},{"location":"cli-architecture/#patterns-et-conventions","title":"Patterns et conventions","text":""},{"location":"cli-architecture/#1-pattern-de-templates","title":"1. Pattern de templates","text":"<p>Choix: String concatenation vs text/template</p> <p>Option choisie: String concatenation</p> <pre><code>return `package main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(\"` + t.projectName + `\")\n}\n`\n</code></pre> <p>Pourquoi pas text/template? - Simplicit\u00e9: Pas de parsing, pas de struct de donn\u00e9es - Performance: Pas d'overhead de parsing - Type-safety: Erreurs \u00e0 la compilation - Debugging: Plus facile de voir le template g\u00e9n\u00e9r\u00e9</p> <p>Challenges: - \u00c9chappement des backticks: Utiliser <code>\"`\"</code> - Templates longs deviennent verbeux</p>"},{"location":"cli-architecture/#2-validation-en-couches","title":"2. Validation en couches","text":"<p>Layer 1 - CLI level (main.go): - Validation du nom de projet - Regex: <code>^[a-zA-Z0-9][a-zA-Z0-9_-]*$</code> - Exemples valides: <code>mon-projet</code>, <code>my_app</code>, <code>app2024</code></p> <p>Layer 2 - Generator level (generator.go): - Validation module name Go (m\u00eame r\u00e8gles que Layer 1) - V\u00e9rification que le r\u00e9pertoire existe</p> <p>Layer 3 - Runtime (code g\u00e9n\u00e9r\u00e9): - Validation avec go-playground/validator - Validation m\u00e9tier dans le domain</p>"},{"location":"cli-architecture/#3-gestion-des-erreurs","title":"3. Gestion des erreurs","text":"<p>Convention:</p> <pre><code>if err != nil {\n    return fmt.Errorf(\"context: %w\", err)  // Wrap error with context\n}\n</code></pre> <p>Affichage utilisateur:</p> <pre><code>fmt.Println(Red(\"\u2717 Error: \" + err.Error()))\nos.Exit(1)\n</code></pre> <p>Pas de panic: Utiliser return error, pas panic()</p>"},{"location":"cli-architecture/#4-tests","title":"4. Tests","text":"<p>Organisation:</p> <pre><code>cmd/create-go-starter/\n\u251c\u2500\u2500 main.go\n\u251c\u2500\u2500 main_test.go           # Tests CLI\n\u251c\u2500\u2500 generator.go\n\u251c\u2500\u2500 generator_test.go      # Tests g\u00e9n\u00e9ration\n\u251c\u2500\u2500 templates.go\n\u251c\u2500\u2500 templates_test.go      # Tests templates\n\u251c\u2500\u2500 colors_test.go         # Tests utilitaires couleurs\n\u2514\u2500\u2500 env_test.go            # Tests .env copy\n</code></pre> <p>Patterns de tests:</p> <ol> <li>Table-driven tests:</li> </ol> <pre><code>func TestValidateProjectName(t *testing.T) {\n    tests := []struct {\n        name    string\n        input   string\n        wantErr bool\n    }{\n        {\"valid simple\", \"myproject\", false},\n        {\"valid with hyphen\", \"my-project\", false},\n        {\"invalid space\", \"my project\", true},\n        {\"invalid special char\", \"my@project\", true},\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            err := validateProjectName(tt.input)\n            if (err != nil) != tt.wantErr {\n                t.Errorf(\"validateProjectName() error = %v, wantErr %v\", err, tt.wantErr)\n            }\n        })\n    }\n}\n</code></pre> <ol> <li>Template validation:</li> </ol> <pre><code>func TestReadmeTemplate(t *testing.T) {\n    templates := NewProjectTemplates(\"test-project\")\n    content := templates.ReadmeTemplate()\n\n    if !strings.Contains(content, \"# test-project\") {\n        t.Error(\"README should contain project name as title\")\n    }\n}\n</code></pre>"},{"location":"cli-architecture/#extensibilite","title":"Extensibilit\u00e9","text":""},{"location":"cli-architecture/#ajouter-un-nouveau-template","title":"Ajouter un nouveau template","text":"<p>\u00c9tapes:</p> <ol> <li>Cr\u00e9er la m\u00e9thode template dans <code>templates.go</code> ou <code>templates_user.go</code>:</li> </ol> <pre><code>func (t *ProjectTemplates) MyNewTemplate() string {\n    return `package mypackage\n\n// Generated code for ` + t.projectName + `\n\nfunc Hello() {\n    fmt.Println(\"Hello from ` + t.projectName + `\")\n}\n`\n}\n</code></pre> <ol> <li>Ajouter FileGenerator dans <code>generator.go</code>:</li> </ol> <pre><code>files := []FileGenerator{\n    // ... existing files\n    {\n        Path:    filepath.Join(projectPath, \"pkg\", \"mypackage\", \"hello.go\"),\n        Content: templates.MyNewTemplate(),\n    },\n}\n</code></pre> <ol> <li>Tester la g\u00e9n\u00e9ration:</li> </ol> <pre><code>go run ./cmd/create-go-starter test-project\ncat test-project/pkg/mypackage/hello.go\n</code></pre> <ol> <li>Ajouter un test dans <code>templates_test.go</code>:</li> </ol> <pre><code>func TestMyNewTemplate(t *testing.T) {\n    templates := NewProjectTemplates(\"test\")\n    content := templates.MyNewTemplate()\n\n    assert.Contains(t, content, \"package mypackage\")\n    assert.Contains(t, content, \"test\")\n}\n</code></pre>"},{"location":"cli-architecture/#ajouter-une-option-cli","title":"Ajouter une option CLI","text":"<p>Exemple: Ajouter <code>--database</code> flag pour choisir la DB</p> <ol> <li>D\u00e9finir le flag dans <code>main.go</code>:</li> </ol> <pre><code>var database string\n\nfunc main() {\n    flag.StringVar(&amp;database, \"database\", \"postgres\", \"Database type (postgres, mysql, sqlite)\")\n    flag.Parse()\n\n    // Validate\n    if database != \"postgres\" &amp;&amp; database != \"mysql\" &amp;&amp; database != \"sqlite\" {\n        fmt.Println(Red(\"\u2717 Invalid database type\"))\n        os.Exit(1)\n    }\n}\n</code></pre> <ol> <li>Passer \u00e0 generateProjectFiles:</li> </ol> <pre><code>func generateProjectFiles(projectPath, projectName, database string) error {\n    templates := NewProjectTemplates(projectName)\n    templates.database = database  // Add field to struct\n\n    // Conditional template generation\n    switch database {\n    case \"postgres\":\n        // Generate PostgreSQL specific files\n    case \"mysql\":\n        // Generate MySQL specific files\n    }\n}\n</code></pre> <ol> <li>Adapter les templates:</li> </ol> <pre><code>func (t *ProjectTemplates) GoModTemplate() string {\n    driver := \"gorm.io/driver/postgres\"\n    if t.database == \"mysql\" {\n        driver = \"gorm.io/driver/mysql\"\n    }\n\n    return `module ` + t.projectName + `\n\nrequire (\n    gorm.io/gorm v1.31.1\n    ` + driver + ` v1.5.11\n)\n`\n}\n</code></pre>"},{"location":"cli-architecture/#modeles-dextension-futurs","title":"Mod\u00e8les d'extension futurs","text":"<p>1. Templates multiples:</p> <pre><code>create-go-starter my-project --template=minimal\ncreate-go-starter my-project --template=full\ncreate-go-starter my-project --template=api-only\ncreate-go-starter my-project --template=graphql\n</code></pre> <p>Impl\u00e9mentation:</p> <pre><code>// templates/minimal.go\ntype MinimalTemplates struct { ... }\n\n// templates/full.go\ntype FullTemplates struct { ... }\n\n// Factory pattern\nfunc NewTemplates(projectName, templateType string) TemplateGenerator {\n    switch templateType {\n    case \"minimal\":\n        return NewMinimalTemplates(projectName)\n    case \"full\":\n        return NewFullTemplates(projectName)\n    }\n}\n</code></pre> <p>2. Choix de DB:</p> <pre><code>create-go-starter my-project --db=mysql\ncreate-go-starter my-project --db=mongodb\n</code></pre> <p>3. Choix de framework:</p> <pre><code>create-go-starter my-project --framework=gin\ncreate-go-starter my-project --framework=echo\n</code></pre> <p>4. CLI interactif:</p> <pre><code>create-go-starter\n\n? Project name: my-awesome-api\n? Database: PostgreSQL\n? Auth: JWT\n? Generate Swagger docs: Yes\n? Include Docker: Yes\n\n\u2713 Generating project...\n</code></pre> <p>Utiliser: <code>github.com/manifoldco/promptui</code></p>"},{"location":"cli-architecture/#dependances","title":"D\u00e9pendances","text":"<p>D\u00e9pendances du CLI: AUCUNE (seulement stdlib)</p> <p>Avantages: - Simplicit\u00e9: Pas de go mod tidy pour le CLI - Portabilit\u00e9: Binaire statique sans d\u00e9pendances - Installation l\u00e9g\u00e8re: <code>go install</code> tr\u00e8s rapide - Maintenance facile: Pas de breaking changes externes</p> <p>Packages stdlib utilis\u00e9s: - <code>flag</code> - Parsing CLI - <code>fmt</code> - Formatting et printing - <code>os</code> - File operations, exit codes - <code>path/filepath</code> - Path manipulation - <code>regexp</code> - Validation patterns - <code>strings</code> - String utilities</p>"},{"location":"cli-architecture/#performance","title":"Performance","text":"<p>M\u00e9triques:</p> <ul> <li>Temps de g\u00e9n\u00e9ration: &lt; 1 seconde pour 45+ fichiers</li> <li>Taille binaire: ~3-4 MB (statique)</li> <li>M\u00e9moire: &lt; 10 MB pendant g\u00e9n\u00e9ration</li> <li>Disk writes: 45+ fichiers, ~15,000 lignes de code g\u00e9n\u00e9r\u00e9es</li> </ul> <p>Optimisations:</p> <ol> <li>Pas de parsing de templates: String concatenation directe</li> <li>Batch file creation: Tous les fichiers cr\u00e9\u00e9s en une passe</li> <li>MkdirAll une fois: Cr\u00e9\u00e9 tous les r\u00e9pertoires parents si n\u00e9cessaire</li> <li>Pas de d\u00e9pendances: Pas de download ni d'import overhead</li> </ol>"},{"location":"cli-architecture/#standards-de-code","title":"Standards de code","text":"<p>Conventions suivies:</p> <ol> <li> <p>gofmt: Toujours format\u00e9    <pre><code>go fmt ./...\n</code></pre></p> </li> <li> <p>golangci-lint: Quality checks    <pre><code>golangci-lint run ./...\n</code></pre></p> </li> <li> <p>Tests coverage: &gt; 80%    <pre><code>go test -cover ./...\n</code></pre></p> </li> <li> <p>Documentation GoDoc: Pour exports publics    <pre><code>// ProjectTemplates holds all template generation methods\ntype ProjectTemplates struct {\n    projectName string\n}\n</code></pre></p> </li> <li> <p>Error handling: Toujours explicite, jamais ignore    <pre><code>if err != nil {\n    return fmt.Errorf(\"context: %w\", err)\n}\n</code></pre></p> </li> </ol>"},{"location":"cli-architecture/#debogage","title":"D\u00e9bogage","text":"<p>Activer mode verbose (\u00e0 impl\u00e9menter):</p> <pre><code>var verbose bool\nflag.BoolVar(&amp;verbose, \"verbose\", false, \"Verbose output\")\n\nif verbose {\n    log.Println(\"Creating directory:\", path)\n    log.Println(\"Writing file:\", filepath)\n}\n</code></pre> <p>Tester g\u00e9n\u00e9ration:</p> <pre><code># G\u00e9n\u00e9rer projet test\ngo run ./cmd/create-go-starter test-project\n\n# V\u00e9rifier fichiers\nls -la test-project/\ntree test-project/\n\n# V\u00e9rifier contenu\ncat test-project/go.mod\ncat test-project/cmd/main.go\n\n# Test build\ncd test-project\ngo mod tidy\ngo build ./...\n\n# Nettoyer\ncd ..\nrm -rf test-project\n</code></pre> <p>Debugger avec Delve:</p> <pre><code>dlv debug ./cmd/create-go-starter -- my-project\n(dlv) break main.createProjectStructure\n(dlv) continue\n</code></pre>"},{"location":"cli-architecture/#contribution","title":"Contribution","text":"<p>Pour contribuer au CLI:</p> <ol> <li>Fork le repository</li> <li>Cr\u00e9er une branche: <code>git checkout -b feature/my-feature</code></li> <li>Faire les changements</li> <li>Tests: <code>go test ./...</code></li> <li>Lint: <code>golangci-lint run</code></li> <li>Commit: <code>git commit -m \"feat: add feature\"</code></li> <li>Push: <code>git push origin feature/my-feature</code></li> <li>Ouvrir une Pull Request</li> </ol> <p>Checklist PR: - [ ] Tests ajout\u00e9s/mis \u00e0 jour - [ ] Tests passent (<code>make test</code>) - [ ] Lint passe (<code>make lint</code>) - [ ] Documentation mise \u00e0 jour - [ ] Commit messages clairs (conventional commits)</p>"},{"location":"cli-architecture/#roadmap-technique","title":"Roadmap technique","text":"<p>Court terme: - [ ] Version flag (<code>--version</code>) - [ ] Verbose mode (<code>--verbose</code>) - [ ] Dry-run mode (<code>--dry-run</code>) - [ ] Force overwrite (<code>--force</code>)</p> <p>Moyen terme: - [ ] Templates multiples (minimal, full, api-only) - [ ] Choix de DB (PostgreSQL, MySQL, SQLite, MongoDB) - [ ] Choix de framework (Fiber, Gin, Echo) - [ ] CLI interactif (prompts)</p> <p>Long terme: - [ ] Plugin system pour templates custom - [ ] Template marketplace - [ ] Hot-reload des templates - [ ] GUI pour g\u00e9n\u00e9ration</p> <p>Cette documentation technique devrait permettre aux contributeurs de comprendre l'architecture interne du CLI et de contribuer efficacement au projet.</p>"},{"location":"contributing/","title":"Guide de contribution","text":"<p>Merci de contribuer \u00e0 <code>create-go-starter</code>! Ce guide vous aidera \u00e0 d\u00e9marrer.</p>"},{"location":"contributing/#code-de-conduite","title":"Code de conduite","text":"<p>En participant \u00e0 ce projet, vous acceptez de:</p> <ul> <li>\u00catre respectueux et inclusif</li> <li>Accepter les critiques constructives</li> <li>Vous concentrer sur ce qui est le mieux pour la communaut\u00e9</li> <li>Faire preuve d'empathie envers les autres contributeurs</li> </ul>"},{"location":"contributing/#comment-contribuer","title":"Comment contribuer","text":"<p>Il y a plusieurs fa\u00e7ons de contribuer:</p> <ol> <li>Signaler des bugs - Aidez-nous \u00e0 am\u00e9liorer en signalant les probl\u00e8mes</li> <li>Proposer des fonctionnalit\u00e9s - Partagez vos id\u00e9es pour am\u00e9liorer l'outil</li> <li>Am\u00e9liorer la documentation - Corrigez ou ajoutez de la documentation</li> <li>Contribuer du code - R\u00e9solvez des issues ou impl\u00e9mentez de nouvelles fonctionnalit\u00e9s</li> <li>Tester - Essayez l'outil et donnez votre feedback</li> </ol>"},{"location":"contributing/#signaler-un-bug","title":"Signaler un bug","text":"<p>Si vous trouvez un bug, cr\u00e9ez une issue GitHub avec:</p>"},{"location":"contributing/#template-de-bug-report","title":"Template de bug report","text":"<pre><code>**Description du bug**\nDescription claire et concise du bug.\n\n**Steps pour reproduire**\n1. \u00c9tape 1\n2. \u00c9tape 2\n3. Voir l'erreur\n\n**Comportement attendu**\nCe qui devrait se passer normalement.\n\n**Comportement actuel**\nCe qui se passe r\u00e9ellement.\n\n**Environment**\n- OS: [ex: macOS 13.0, Ubuntu 22.04, Windows 11]\n- Version Go: [ex: 1.25.0]\n- Version create-go-starter: [ex: v1.0.0]\n- Commande ex\u00e9cut\u00e9e: [ex: `create-go-starter my-project`]\n\n**Logs/Screenshots**\nAjoutez des logs ou screenshots si pertinent.\n\n**Contexte additionnel**\nTout autre contexte utile.\n</code></pre> <p>O\u00f9 signaler: GitHub Issues</p>"},{"location":"contributing/#proposer-une-fonctionnalite","title":"Proposer une fonctionnalit\u00e9","text":"<p>Avant de proposer une feature, v\u00e9rifiez qu'elle n'a pas d\u00e9j\u00e0 \u00e9t\u00e9 propos\u00e9e.</p>"},{"location":"contributing/#template-de-feature-request","title":"Template de feature request","text":"<pre><code>**Probl\u00e8me \u00e0 r\u00e9soudre**\nQuel probl\u00e8me cette fonctionnalit\u00e9 r\u00e9sout-elle?\n\n**Solution propos\u00e9e**\nComment pensez-vous que cela devrait fonctionner?\n\n**Alternatives consid\u00e9r\u00e9es**\nAvez-vous pens\u00e9 \u00e0 d'autres approches?\n\n**Use cases**\nExemples d'utilisation de cette fonctionnalit\u00e9.\n\n**Impact**\nQui b\u00e9n\u00e9ficierait de cette fonctionnalit\u00e9?\n</code></pre> <p>O\u00f9 proposer: GitHub Discussions</p>"},{"location":"contributing/#contribuer-du-code","title":"Contribuer du code","text":""},{"location":"contributing/#prerequis","title":"Pr\u00e9requis","text":"<ul> <li>Go 1.25+ - T\u00e9l\u00e9charger</li> <li>Git - Pour cloner et contribuer</li> <li>golangci-lint (optionnel) - Pour le linting</li> <li>Make - Pour les commandes de build</li> </ul>"},{"location":"contributing/#setup-de-developpement","title":"Setup de d\u00e9veloppement","text":""},{"location":"contributing/#1-fork-et-clone","title":"1. Fork et clone","text":"<pre><code># Fork le repository sur GitHub (bouton Fork)\n\n# Clone votre fork\ngit clone https://github.com/tky0065/go-starter-kit.git\ncd go-starter-kit\n\n# Ajouter le repository upstream\ngit remote add upstream https://github.com/tky0065/go-starter-kit.git\n</code></pre>"},{"location":"contributing/#2-installer-les-dependances-de-developpement","title":"2. Installer les d\u00e9pendances de d\u00e9veloppement","text":"<pre><code># Installer golangci-lint (optionnel)\n# macOS\nbrew install golangci-lint\n\n# Linux\ncurl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- -b $(go env GOPATH)/bin\n\n# Ou avec go install\ngo install github.com/golangci/golangci-lint/cmd/golangci-lint@latest\n</code></pre>"},{"location":"contributing/#3-build-et-test","title":"3. Build et test","text":"<pre><code># Build le CLI\nmake build\n# ou\ngo build -o create-go-starter ./cmd/create-go-starter\n\n# Tests\nmake test\n\n# Lint\nmake lint\n</code></pre>"},{"location":"contributing/#workflow-de-contribution","title":"Workflow de contribution","text":""},{"location":"contributing/#1-creer-une-branche","title":"1. Cr\u00e9er une branche","text":"<pre><code># Sync avec upstream\ngit fetch upstream\ngit checkout main\ngit merge upstream/main\n\n# Cr\u00e9er une branche pour votre feature/fix\ngit checkout -b feature/ma-fonctionnalite\n# ou\ngit checkout -b fix/mon-bug-fix\n</code></pre> <p>Conventions de nommage de branches: - <code>feature/nom-de-la-feature</code> - Nouvelle fonctionnalit\u00e9 - <code>fix/description-du-fix</code> - Bug fix - <code>docs/sujet-de-la-doc</code> - Documentation - <code>refactor/description</code> - Refactoring - <code>test/description</code> - Ajout/am\u00e9lioration de tests</p>"},{"location":"contributing/#2-faire-vos-changements","title":"2. Faire vos changements","text":"<pre><code># \u00c9ditez les fichiers\n# Suivez les standards de code (voir section Standards)\n\n# Ajoutez des tests pour votre code\n# internal/adapters/handlers/handler_test.go\n</code></pre> <p>Best practices: - Une feature/fix par branche: Ne m\u00e9langez pas plusieurs changements - Tests obligatoires: Ajoutez des tests pour tout nouveau code - Documentation: Mettez \u00e0 jour la doc si n\u00e9cessaire - Commits atomiques: Commits petits et focalis\u00e9s</p>"},{"location":"contributing/#3-tester-vos-changements","title":"3. Tester vos changements","text":"<pre><code># Run tests\nmake test\n\n# V\u00e9rifier coverage\nmake test-coverage\n\n# Lint\nmake lint\n\n# Test manuel\n./create-go-starter test-project\ncd test-project\ngo mod tidy\nmake run\n</code></pre> <p>Checklist de tests: - [ ] Tous les tests passent (<code>make test</code>) - [ ] Lint passe (<code>make lint</code>) - [ ] Coverage &gt; 80% pour le nouveau code - [ ] Tests manuels effectu\u00e9s (g\u00e9n\u00e9ration de projet) - [ ] Projet g\u00e9n\u00e9r\u00e9 compile (<code>go build ./...</code>) - [ ] Projet g\u00e9n\u00e9r\u00e9 fonctionne (<code>make run</code>)</p>"},{"location":"contributing/#4-commit-vos-changements","title":"4. Commit vos changements","text":"<p>Utilisez Conventional Commits:</p> <pre><code>git add .\ngit commit -m \"feat: ajouter support pour MySQL\"\n# ou\ngit commit -m \"fix: corriger validation du nom de projet\"\n# ou\ngit commit -m \"docs: am\u00e9liorer guide d'installation\"\n</code></pre> <p>Format des commits:</p> <pre><code>&lt;type&gt;(&lt;scope&gt;): &lt;description&gt;\n\n[optional body]\n\n[optional footer]\n</code></pre> <p>Types: - <code>feat</code>: Nouvelle fonctionnalit\u00e9 - <code>fix</code>: Bug fix - <code>docs</code>: Documentation seulement - <code>style</code>: Formatage (pas de changement de code) - <code>refactor</code>: Refactoring (ni feature ni fix) - <code>test</code>: Ajout/modification de tests - <code>chore</code>: Maintenance (build, deps, etc.) - <code>perf</code>: Am\u00e9lioration de performance</p> <p>Scope (optionnel): - <code>cli</code>: CLI interface (main.go) - <code>generator</code>: File generation (generator.go) - <code>templates</code>: Templates (templates.go) - <code>tests</code>: Tests - <code>docs</code>: Documentation</p> <p>Exemples:</p> <pre><code>feat(templates): add MySQL database template\nfix(cli): validate project name with correct regex\ndocs(readme): update installation instructions\nrefactor(generator): simplify file creation logic\ntest(templates): add tests for ReadmeTemplate\nchore(deps): update golangci-lint to v1.55\n</code></pre> <p>Message body (optionnel mais recommand\u00e9):</p> <pre><code>git commit -m \"feat(templates): add MySQL support\n\n- Add MySQLDatabaseTemplate method\n- Update go.mod template to include mysql driver\n- Add flag --database to choose DB type\n\nCloses #42\"\n</code></pre>"},{"location":"contributing/#5-push-vers-votre-fork","title":"5. Push vers votre fork","text":"<pre><code>git push origin feature/ma-fonctionnalite\n</code></pre>"},{"location":"contributing/#6-creer-une-pull-request","title":"6. Cr\u00e9er une Pull Request","text":"<ol> <li>Allez sur GitHub: https://github.com/tky0065/go-starter-kit</li> <li>Cliquez sur \"Compare &amp; pull request\"</li> <li>Remplissez le template de PR (voir ci-dessous)</li> <li>Soumettez la PR</li> </ol>"},{"location":"contributing/#template-de-pull-request","title":"Template de Pull Request","text":"<p>Quand vous cr\u00e9ez une PR, utilisez ce template:</p> <pre><code>## Description\n\nD\u00e9crivez vos changements en quelques lignes.\n\n## Type de changement\n\n- [ ] Bug fix (changement qui corrige un issue)\n- [ ] Nouvelle fonctionnalit\u00e9 (changement qui ajoute une fonctionnalit\u00e9)\n- [ ] Breaking change (fix ou feature qui changerait le comportement existant)\n- [ ] Documentation seulement\n\n## Motivation et contexte\n\nPourquoi ce changement est-il n\u00e9cessaire? Quel probl\u00e8me r\u00e9sout-il?\n\nFixes #(issue)\n\n## Comment a \u00e9t\u00e9 test\u00e9?\n\nD\u00e9crivez les tests que vous avez effectu\u00e9s.\n\n- [ ] Tests unitaires ajout\u00e9s/mis \u00e0 jour\n- [ ] Tests manuels effectu\u00e9s\n- [ ] Projet g\u00e9n\u00e9r\u00e9 compile et fonctionne\n\n## Checklist\n\n- [ ] Mon code suit les standards du projet\n- [ ] J'ai effectu\u00e9 une auto-review de mon code\n- [ ] J'ai comment\u00e9 mon code dans les zones complexes\n- [ ] J'ai mis \u00e0 jour la documentation si n\u00e9cessaire\n- [ ] Mes changements ne g\u00e9n\u00e8rent pas de warnings\n- [ ] J'ai ajout\u00e9 des tests qui prouvent que mon fix/feature fonctionne\n- [ ] Tous les tests passent (nouveau et existants)\n- [ ] Lint passe sans erreurs\n\n## Screenshots (si applicable)\n\nAjoutez des screenshots pour aider \u00e0 expliquer vos changements.\n</code></pre>"},{"location":"contributing/#standards-de-code","title":"Standards de code","text":"<p>Pour maintenir la qualit\u00e9 et la coh\u00e9rence du code:</p>"},{"location":"contributing/#1-formatage","title":"1. Formatage","text":"<p>Toujours formater avec <code>gofmt</code>:</p> <pre><code>go fmt ./...\n</code></pre> <p>Ou configurez votre IDE/\u00e9diteur pour formater \u00e0 la sauvegarde.</p>"},{"location":"contributing/#2-linting","title":"2. Linting","text":"<p>Utilisez <code>golangci-lint</code> pour v\u00e9rifier la qualit\u00e9:</p> <pre><code>make lint\n# ou\ngolangci-lint run ./...\n</code></pre> <p>Configuration: <code>.golangci.yml</code> \u00e0 la racine du projet.</p> <p>R\u00e8gles principales: - errcheck, gosimple, govet, ineffassign, staticcheck - gofmt, goimports - misspell, revive - Pas d'unused vars, unused params</p>"},{"location":"contributing/#3-naming-conventions","title":"3. Naming conventions","text":"<p>Suivez les conventions Go:</p> <p>Variables et fonctions: - <code>camelCase</code> pour priv\u00e9 - <code>PascalCase</code> pour public - Noms descriptifs (pas d'abr\u00e9viations sauf idiomatiques)</p> <p>Exemples:</p> <pre><code>// \u2705 Bon\nprojectName string\nvalidateProjectName() error\nGenerateFiles() error\n\n// \u274c Mauvais\npn string\nvalProjName() error\ngenFiles() error\n</code></pre> <p>Constantes:</p> <pre><code>const (\n    DefaultPort     = 8080\n    MaxNameLength   = 100\n    ValidationRegex = `^[a-zA-Z0-9][a-zA-Z0-9_-]*$`\n)\n</code></pre>"},{"location":"contributing/#4-error-handling","title":"4. Error handling","text":"<p>Toujours g\u00e9rer les erreurs explicitement:</p> <pre><code>// \u2705 Bon\nif err != nil {\n    return fmt.Errorf(\"failed to create file %s: %w\", path, err)\n}\n\n// \u274c Mauvais\nos.WriteFile(path, content, 0644)  // Ignore error\n</code></pre> <p>Wrapping errors avec contexte:</p> <pre><code>if err != nil {\n    return fmt.Errorf(\"generateProjectFiles: %w\", err)\n}\n</code></pre>"},{"location":"contributing/#5-documentation","title":"5. Documentation","text":"<p>Documenter tous les exports publics avec GoDoc:</p> <pre><code>// ProjectTemplates holds all template generation methods for creating\n// project files. It uses the project name to inject dynamic content\n// into the generated templates.\ntype ProjectTemplates struct {\n    projectName string\n}\n\n// NewProjectTemplates creates a new ProjectTemplates instance with\n// the given project name. The project name will be used throughout\n// all template generation.\nfunc NewProjectTemplates(projectName string) *ProjectTemplates {\n    return &amp;ProjectTemplates{projectName: projectName}\n}\n</code></pre> <p>Format: - Phrase compl\u00e8te commen\u00e7ant par le nom - Pas de point \u00e0 la fin si une seule phrase - Point \u00e0 la fin si plusieurs phrases</p>"},{"location":"contributing/#6-tests","title":"6. Tests","text":"<p>Coverage minimum: 80%</p> <pre><code>go test -cover ./...\n</code></pre> <p>Patterns:</p> <ol> <li>Table-driven tests:</li> </ol> <pre><code>func TestValidateProjectName(t *testing.T) {\n    tests := []struct {\n        name    string\n        input   string\n        wantErr bool\n    }{\n        {\"valid simple\", \"project\", false},\n        {\"valid with hyphen\", \"my-project\", false},\n        {\"invalid space\", \"my project\", true},\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            err := validateProjectName(tt.input)\n            if (err != nil) != tt.wantErr {\n                t.Errorf(\"got error = %v, want error = %v\", err, tt.wantErr)\n            }\n        })\n    }\n}\n</code></pre> <ol> <li>Noms de tests descriptifs:</li> </ol> <pre><code>func TestGenerateProjectFiles_WithValidName_CreatesAllFiles(t *testing.T)\nfunc TestGenerateProjectFiles_WithInvalidName_ReturnsError(t *testing.T)\n</code></pre> <ol> <li>Setup et teardown:</li> </ol> <pre><code>func TestSomething(t *testing.T) {\n    // Setup\n    tmpDir := t.TempDir()  // Auto-cleaned up\n\n    // Test\n    // ...\n\n    // Teardown automatique avec t.TempDir()\n}\n</code></pre>"},{"location":"contributing/#7-imports","title":"7. Imports","text":"<p>Grouper les imports par cat\u00e9gorie:</p> <pre><code>import (\n    // Standard library\n    \"fmt\"\n    \"os\"\n    \"path/filepath\"\n\n    // Third-party (si on en avait)\n    \"github.com/some/package\"\n\n    // Internal (si applicable)\n    \"go-starter-kit/internal/something\"\n)\n</code></pre>"},{"location":"contributing/#processus-de-review","title":"Processus de review","text":""},{"location":"contributing/#quand-vous-soumettez-une-pr","title":"Quand vous soumettez une PR","text":"<ol> <li>Auto-review: Relisez votre code avant de soumettre</li> <li>CI checks: Attendez que GitHub Actions passe</li> <li>Reviews: Au moins 1 review requis</li> <li>Changements: Int\u00e9grez le feedback</li> <li>Merge: Une fois approuv\u00e9e, un maintainer mergera</li> </ol>"},{"location":"contributing/#quand-vous-reviewez-une-pr","title":"Quand vous reviewez une PR","text":"<p>Checklist de review:</p> <ul> <li> Le code suit les standards du projet</li> <li> Les tests sont pr\u00e9sents et passent</li> <li> La documentation est \u00e0 jour</li> <li> Pas de code dupliqu\u00e9</li> <li> Pas de bug \u00e9vidents</li> <li> Performance acceptable</li> <li> Pas de secrets/credentials dans le code</li> </ul> <p>Comment donner du feedback: - Soyez constructif et respectueux - Expliquez le \"pourquoi\", pas juste le \"quoi\" - Proposez des alternatives - Utilisez des suggestions de code GitHub</p>"},{"location":"contributing/#roadmap","title":"Roadmap","text":"<p>Fonctionnalit\u00e9s pr\u00e9vues pour les prochaines versions:</p>"},{"location":"contributing/#v11-templates-multiples","title":"v1.1 - Templates multiples","text":"<ul> <li> Template \"minimal\" (API seulement, sans auth)</li> <li> Template \"full\" (tout inclus, actuel)</li> <li> Template \"microservice\" (avec gRPC)</li> <li> Flag <code>--template=&lt;type&gt;</code></li> </ul>"},{"location":"contributing/#v12-choix-de-base-de-donnees","title":"v1.2 - Choix de base de donn\u00e9es","text":"<ul> <li> Support MySQL</li> <li> Support SQLite</li> <li> Support MongoDB</li> <li> Flag <code>--database=&lt;type&gt;</code></li> </ul>"},{"location":"contributing/#v13-choix-de-framework-web","title":"v1.3 - Choix de framework web","text":"<ul> <li> Support Gin</li> <li> Support Echo</li> <li> Support Chi</li> <li> Flag <code>--framework=&lt;type&gt;</code></li> </ul>"},{"location":"contributing/#v14-features-avancees","title":"v1.4 - Features avanc\u00e9es","text":"<ul> <li> CLI interactif (prompts)</li> <li> GraphQL template</li> <li> gRPC template</li> <li> WebSocket support</li> <li> Event sourcing template</li> </ul>"},{"location":"contributing/#v20-plugin-system","title":"v2.0 - Plugin system","text":"<ul> <li> Plugin API pour templates custom</li> <li> Template marketplace</li> <li> Hot-reload des templates</li> <li> GUI pour g\u00e9n\u00e9ration</li> </ul> <p>Comment contribuer au roadmap: - Votez pour les features dans Discussions - Proposez de nouvelles id\u00e9es - Impl\u00e9mentez une feature du roadmap</p>"},{"location":"contributing/#questions","title":"Questions?","text":"<p>Si vous avez des questions:</p> <ul> <li>GitHub Discussions: Pour questions g\u00e9n\u00e9rales, id\u00e9es</li> <li>GitHub Issues: Pour bugs sp\u00e9cifiques</li> <li>Pull Requests: Pour proposer du code</li> </ul>"},{"location":"contributing/#remerciements","title":"Remerciements","text":"<p>Merci \u00e0 tous les contributeurs qui aident \u00e0 am\u00e9liorer <code>create-go-starter</code>!</p> <p>Chaque contribution, grande ou petite, fait une diff\u00e9rence. \ud83d\ude4f</p> <p>Bon coding et merci de contribuer! \ud83d\ude80</p>"},{"location":"generated-project-guide/","title":"Guide des projets g\u00e9n\u00e9r\u00e9s","text":"<p>Guide complet pour d\u00e9velopper, tester et d\u00e9ployer les projets cr\u00e9\u00e9s avec create-go-starter</p>"},{"location":"generated-project-guide/#table-des-matieres","title":"Table des mati\u00e8res","text":"<ol> <li>Architecture</li> <li>Configuration</li> <li>D\u00e9veloppement</li> <li>API Reference</li> <li>Tests</li> <li>Base de donn\u00e9es</li> <li>S\u00e9curit\u00e9</li> <li>D\u00e9ploiement</li> <li>Monitoring &amp; Logging</li> <li>Bonnes pratiques</li> </ol>"},{"location":"generated-project-guide/#architecture","title":"Architecture","text":""},{"location":"generated-project-guide/#architecture-hexagonale-ports-adapters","title":"Architecture hexagonale (Ports &amp; Adapters)","text":"<p>Les projets g\u00e9n\u00e9r\u00e9s suivent l'architecture hexagonale, \u00e9galement appel\u00e9e \"Ports and Adapters\".</p> <p>Principe fondamental: Le domaine m\u00e9tier (business logic) est au centre et ne d\u00e9pend de rien. Toutes les d\u00e9pendances pointent vers le domaine.</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   HTTP Layer (Fiber)                    \u2502\n\u2502              adapters/handlers + middleware             \u2502\n\u2502  \u2022 AuthHandler (register, login, refresh)               \u2502\n\u2502  \u2022 UserHandler (CRUD operations)                        \u2502\n\u2502  \u2022 AuthMiddleware (JWT verification)                    \u2502\n\u2502  \u2022 ErrorHandler (centralized error handling)            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                        \u2502\n                        \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              Shared Entities Layer                      \u2502\n\u2502                   models/                               \u2502\n\u2502  \u2022 User (entity with GORM tags)                         \u2502\n\u2502  \u2022 RefreshToken (entity with GORM tags)                 \u2502\n\u2502  \u2022 AuthResponse (DTO)                                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           \u2502                           \u2502\n           \u25bc                           \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Interfaces Layer   \u2502  \u2502      Domain Layer            \u2502\n\u2502   interfaces/        \u2502  \u2502      domain/user             \u2502\n\u2502  \u2022 UserRepository    \u2502  \u2502  \u2022 UserService (logic)       \u2502\n\u2502    (port)            \u2502  \u2502  \u2022 Business rules            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           \u2502\n           \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              Infrastructure Layer                       \u2502\n\u2502         database + repository + server                  \u2502\n\u2502  \u2022 GORM Database Connection                             \u2502\n\u2502  \u2022 UserRepository (GORM implementation)                 \u2502\n\u2502  \u2022 Fiber Server Configuration                           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"generated-project-guide/#diagramme-darchitecture-complete-mermaid","title":"Diagramme d'architecture compl\u00e8te (Mermaid)","text":"<p>Le diagramme suivant montre l'architecture hexagonale compl\u00e8te avec tous les composants et leurs interactions :</p> <pre><code>flowchart TB\n    subgraph External[\"Monde Externe\"]\n        Client[\"Client HTTP&lt;br/&gt;(Web, Mobile, API)\"]\n        DB[(\"PostgreSQL&lt;br/&gt;Database\")]\n    end\n\n    subgraph Adapters[\"Adapters Layer\"]\n        direction TB\n        subgraph Inbound[\"Inbound Adapters (Entree)\"]\n            Handlers[\"Handlers&lt;br/&gt;AuthHandler&lt;br/&gt;UserHandler\"]\n            Middleware[\"Middleware&lt;br/&gt;AuthMiddleware&lt;br/&gt;ErrorHandler\"]\n        end\n        subgraph Outbound[\"Outbound Adapters (Sortie)\"]\n            RepoImpl[\"Repository GORM&lt;br/&gt;UserRepository\"]\n        end\n    end\n\n    subgraph Core[\"Core Business (Hexagone)\"]\n        direction TB\n        Models[\"Models (Entites)&lt;br/&gt;User&lt;br/&gt;RefreshToken\"]\n        Domain[\"Domain Services&lt;br/&gt;UserService&lt;br/&gt;Business Logic\"]\n        Interfaces[\"Interfaces/Ports&lt;br/&gt;UserRepository&lt;br/&gt;UserService\"]\n        Errors[\"Domain Errors&lt;br/&gt;NotFound&lt;br/&gt;Validation&lt;br/&gt;Conflict\"]\n    end\n\n    subgraph Infrastructure[\"Infrastructure Layer\"]\n        Server[\"Fiber Server&lt;br/&gt;Routes et Config\"]\n        DBConn[\"Database Connection&lt;br/&gt;GORM Setup\"]\n        Config[\"Configuration&lt;br/&gt;Environment vars\"]\n    end\n\n    subgraph Packages[\"Packages Reutilisables (pkg/)\"]\n        Auth[\"Auth Package&lt;br/&gt;JWT Generation&lt;br/&gt;Token Parsing\"]\n        Logger[\"Logger Package&lt;br/&gt;Zerolog Config\"]\n        ConfigPkg[\"Config Package&lt;br/&gt;Env Loading\"]\n    end\n\n    Client --&gt;|\"HTTP Request\"| Server\n    Server --&gt;|\"Route\"| Handlers\n    Handlers --&gt; Middleware\n    Handlers --&gt;|\"Appelle\"| Domain\n    Domain --&gt;|\"Utilise\"| Interfaces\n    Domain --&gt;|\"Utilise\"| Models\n    Domain --&gt;|\"Retourne\"| Errors\n    RepoImpl -.-&gt;|\"Implemente\"| Interfaces\n    RepoImpl --&gt;|\"Utilise\"| Models\n    RepoImpl --&gt;|\"Query\"| DBConn\n    DBConn --&gt;|\"SQL\"| DB\n    Handlers --&gt;|\"Utilise\"| Auth\n    Server --&gt;|\"Utilise\"| Config\n    Domain --&gt;|\"Utilise\"| Logger</code></pre>"},{"location":"generated-project-guide/#flux-dune-requete-http-sequence-diagram","title":"Flux d'une requete HTTP (Sequence Diagram)","text":"<p>Ce diagramme montre le parcours complet d'une requete HTTP a travers l'architecture :</p> <pre><code>sequenceDiagram\n    autonumber\n    participant C as Client\n    participant S as Server (Fiber)\n    participant M as Middleware\n    participant H as Handler\n    participant SVC as Service\n    participant P as Port (Interface)\n    participant R as Repository\n    participant DB as Database\n\n    C-&gt;&gt;S: POST /api/v1/auth/register\n    S-&gt;&gt;M: Route vers Handler\n    M-&gt;&gt;M: Validation (si protege)\n    M-&gt;&gt;H: Requete validee\n\n    rect rgb(240, 248, 255)\n        Note over H: Handler Layer\n        H-&gt;&gt;H: Parse JSON Body\n        H-&gt;&gt;H: Validate Input (validator)\n    end\n\n    H-&gt;&gt;SVC: service.Register(email, password)\n\n    rect rgb(255, 250, 240)\n        Note over SVC: Domain Layer\n        SVC-&gt;&gt;SVC: Hash Password (bcrypt)\n        SVC-&gt;&gt;SVC: Business Validation\n    end\n\n    SVC-&gt;&gt;P: repo.Create(user)\n    P-&gt;&gt;R: Appel implementation\n\n    rect rgb(240, 255, 240)\n        Note over R: Repository Layer\n        R-&gt;&gt;DB: INSERT INTO users...\n        DB--&gt;&gt;R: User cree (ID)\n    end\n\n    R--&gt;&gt;SVC: User entity\n    SVC--&gt;&gt;H: User + nil error\n    H-&gt;&gt;H: Generate JWT tokens\n    H--&gt;&gt;C: HTTP 201 + JSON Response</code></pre>"},{"location":"generated-project-guide/#principe-de-linversion-de-dependances","title":"Principe de l'Inversion de Dependances","text":"<p>Le coeur de l'architecture hexagonale repose sur l'Inversion de Dependances :</p> <pre><code>flowchart LR\n    subgraph Traditional[\"Approche Traditionnelle\"]\n        direction TB\n        T_Handler[\"Handler\"] --&gt; T_Service[\"Service\"]\n        T_Service --&gt; T_Repo[\"Repository\"]\n        T_Repo --&gt; T_DB[\"Database\"]\n    end\n\n    subgraph Hexagonal[\"Architecture Hexagonale\"]\n        direction TB\n        H_Handler[\"Handler\"]\n        H_Service[\"Service\"]\n        H_Interface[\"Interface&lt;br/&gt;(Port)\"]\n        H_Repo[\"Repository&lt;br/&gt;(Adapter)\"]\n        H_DB[\"Database\"]\n\n        H_Handler --&gt; H_Service\n        H_Service --&gt; H_Interface\n        H_Repo -.-&gt;|\"implemente\"| H_Interface\n        H_Repo --&gt; H_DB\n    end</code></pre> <p>Avantages de cette approche :</p> Aspect Sans Hexagonal Avec Hexagonal Testabilite Difficile (depend de la DB) Facile (mock des interfaces) Changement de DB Modifications partout Seulement le repository Changement de framework Refactoring complet Seulement les handlers Logique metier Dispersee Centralisee dans le domain"},{"location":"generated-project-guide/#structure-des-fichiers-et-responsabilites","title":"Structure des fichiers et responsabilites","text":"<pre><code>flowchart TD\n    subgraph CMD[\"cmd/\"]\n        Main[\"main.go&lt;br/&gt;Bootstrap fx.New()\"]\n    end\n\n    subgraph Internal[\"internal/\"]\n        subgraph Models[\"models/\"]\n            User[\"user.go&lt;br/&gt;Entites GORM\"]\n        end\n\n        subgraph Domain[\"domain/\"]\n            DErrors[\"errors.go&lt;br/&gt;Erreurs metier\"]\n            subgraph UserDomain[\"user/\"]\n                Service[\"service.go&lt;br/&gt;Logique metier\"]\n                Module[\"module.go&lt;br/&gt;fx.Module\"]\n            end\n        end\n\n        subgraph InterfacesPkg[\"interfaces/\"]\n            Repos[\"*_repository.go&lt;br/&gt;Ports (abstractions)\"]\n        end\n\n        subgraph AdaptersPkg[\"adapters/\"]\n            subgraph HandlersPkg[\"handlers/\"]\n                AuthH[\"auth_handler.go\"]\n                UserH[\"user_handler.go\"]\n            end\n            subgraph HttpPkg[\"http/\"]\n                Health[\"health.go\"]\n                Routes[\"routes.go&lt;br/&gt;Routes centralisees\"]\n            end\n            subgraph MiddlewarePkg[\"middleware/\"]\n                AuthM[\"auth_middleware.go\"]\n                ErrorM[\"error_handler.go\"]\n            end\n            subgraph RepoPkg[\"repository/\"]\n                UserRepo[\"user_repository.go&lt;br/&gt;Implementation GORM\"]\n            end\n        end\n\n        subgraph Infra[\"infrastructure/\"]\n            DBPkg[\"database/&lt;br/&gt;Connexion GORM\"]\n            ServerPkg[\"server/&lt;br/&gt;Config Fiber\"]\n        end\n    end\n\n    subgraph Pkg[\"pkg/\"]\n        AuthPkg[\"auth/&lt;br/&gt;JWT utilities\"]\n        ConfigPkg2[\"config/&lt;br/&gt;Env loading\"]\n        LoggerPkg[\"logger/&lt;br/&gt;Zerolog setup\"]\n    end\n\n    Main --&gt; Domain\n    Main --&gt; Infra\n    Main --&gt; Pkg\n    HandlersPkg --&gt; Domain\n    HttpPkg --&gt; HandlersPkg\n    Domain --&gt; InterfacesPkg\n    RepoPkg -.-&gt; InterfacesPkg\n    RepoPkg --&gt; Models\n    Domain --&gt; Models</code></pre> <p>Flux de donn\u00e9es:</p> <ol> <li>Requ\u00eate HTTP \u2192 Handler (adapters/handlers)</li> <li>Handler \u2192 Appelle le Service via l'interface (domain)</li> <li>Service \u2192 Ex\u00e9cute la logique m\u00e9tier, appelle le Repository via l'interface</li> <li>Repository \u2192 Persiste dans la DB (infrastructure)</li> <li>Retour \u2192 Remonte jusqu'au Handler qui retourne la r\u00e9ponse HTTP</li> </ol> <p>Avantages:</p> <ul> <li>Testabilit\u00e9: Le domaine peut \u00eatre test\u00e9 sans DB ni HTTP</li> <li>Flexibilit\u00e9: Changement de DB (PostgreSQL \u2192 MySQL) ou framework (Fiber \u2192 Gin) facile</li> <li>Maintenabilit\u00e9: S\u00e9paration claire des responsabilit\u00e9s</li> <li>\u00c9volutivit\u00e9: Ajout de nouvelles fonctionnalit\u00e9s sans casser l'existant</li> </ul>"},{"location":"generated-project-guide/#stack-technique","title":"Stack technique","text":""},{"location":"generated-project-guide/#web-framework-fiber-v2","title":"Web Framework: Fiber v2","text":"<p>Pourquoi Fiber?</p> <ul> <li>Performance exceptionnelle (built on fasthttp)</li> <li>API famili\u00e8re (inspir\u00e9e d'Express.js)</li> <li>Middleware riche</li> <li>Documentation excellente</li> </ul> <p>Configuration: <code>internal/infrastructure/server/server.go</code></p> <pre><code>app := fiber.New(fiber.Config{\n    ErrorHandler: errorHandler.Handle,\n    ReadTimeout:  10 * time.Second,\n    WriteTimeout: 10 * time.Second,\n})\n</code></pre> <p>Routes: Centralis\u00e9es dans <code>internal/adapters/http/routes.go</code></p> <pre><code>// routes.go - Toutes les routes de l'application\nfunc RegisterRoutes(\n    app *fiber.App,\n    authHandler *handlers.AuthHandler,\n    userHandler *handlers.UserHandler,\n    authMiddleware fiber.Handler,\n) {\n    // Health &amp; Swagger\n    RegisterHealthRoutes(app)\n    app.Get(\"/swagger/*\", swagger.WrapHandler)\n\n    // API v1\n    api := app.Group(\"/api\")\n    v1 := api.Group(\"/v1\")\n\n    // Auth routes (public)\n    auth := v1.Group(\"/auth\")\n    auth.Post(\"/register\", authHandler.Register)\n    auth.Post(\"/login\", authHandler.Login)\n    auth.Post(\"/refresh\", authHandler.Refresh)\n\n    // User routes (protected)\n    users := v1.Group(\"/users\", authMiddleware)\n    users.Get(\"/me\", userHandler.GetMe)\n    users.Get(\"\", userHandler.GetAllUsers)\n    users.Put(\"/:id\", userHandler.UpdateUser)\n    users.Delete(\"/:id\", userHandler.DeleteUser)\n}\n</code></pre> <p>Avantages de la centralisation des routes: - Vue d'ensemble de toutes les routes API en un seul fichier - Facilite la documentation et le versioning de l'API - S\u00e9paration claire entre la d\u00e9finition des routes et la logique des handlers</p>"},{"location":"generated-project-guide/#orm-gorm","title":"ORM: GORM","text":"<p>Pourquoi GORM?</p> <ul> <li>ORM le plus populaire en Go</li> <li>Migrations automatiques</li> <li>Hooks et callbacks</li> <li>Associations et preloading</li> <li>Raw SQL quand n\u00e9cessaire</li> </ul> <p>Configuration: <code>internal/infrastructure/database/database.go</code></p> <pre><code>db, err := gorm.Open(postgres.Open(dsn), &amp;gorm.Config{\n    Logger: logger.Default.LogMode(logger.Info),\n})\n\n// Auto-migration\ndb.AutoMigrate(&amp;models.User{}, &amp;models.RefreshToken{})\n</code></pre> <p>Patterns utilis\u00e9s:</p> <ul> <li>Repository pattern pour isolation</li> <li>Soft deletes (DeletedAt)</li> <li>Timestamps automatiques</li> <li>Indexes sur cl\u00e9s \u00e9trang\u00e8res</li> </ul>"},{"location":"generated-project-guide/#dependency-injection-uber-gofx","title":"Dependency Injection: uber-go/fx","text":"<p>Pourquoi fx?</p> <ul> <li>Gestion propre des d\u00e9pendances</li> <li>Lifecycle hooks (OnStart, OnStop)</li> <li>Parall\u00e9lisation du d\u00e9marrage</li> <li>Erreurs claires \u00e0 la compilation</li> </ul> <p>Pattern Module: Chaque package expose un module fx</p> <pre><code>// domain/user/module.go\nvar Module = fx.Module(\"user\",\n    fx.Provide(\n        NewService,       // Fournit UserService\n        NewUserHandler,   // Fournit UserHandler\n        NewAuthHandler,   // Fournit AuthHandler\n    ),\n)\n</code></pre> <p>Bootstrap: <code>cmd/main.go</code></p> <pre><code>fx.New(\n    logger.Module,      // Logger\n    config.Module,      // Configuration\n    database.Module,    // Database\n    auth.Module,        // JWT utilities\n    user.Module,        // User domain\n    server.Module,      // Fiber server\n).Run()\n</code></pre>"},{"location":"generated-project-guide/#logging-zerolog","title":"Logging: zerolog","text":"<p>Pourquoi zerolog?</p> <ul> <li>Logging structur\u00e9 (JSON)</li> <li>Performance optimale (zero-allocation)</li> <li>Niveaux de log (Debug, Info, Warn, Error, Fatal)</li> <li>Contexte riche</li> </ul> <p>Usage:</p> <pre><code>logger.Info().\n    Str(\"email\", user.Email).\n    Uint(\"user_id\", user.ID).\n    Msg(\"User registered successfully\")\n\nlogger.Error().\n    Err(err).\n    Str(\"operation\", \"create_user\").\n    Msg(\"Failed to create user\")\n</code></pre>"},{"location":"generated-project-guide/#validation-go-playgroundvalidator-v10","title":"Validation: go-playground/validator v10","text":"<p>Validation des requ\u00eates HTTP:</p> <pre><code>type RegisterRequest struct {\n    Email    string `json:\"email\" validate:\"required,email,max=255\"`\n    Password string `json:\"password\" validate:\"required,min=8,max=72\"`\n}\n\n// Dans le handler\nif err := validate.Struct(req); err != nil {\n    // Retourner erreur de validation\n}\n</code></pre> <p>Tags disponibles: required, email, min, max, uuid, url, alpha, numeric, etc.</p>"},{"location":"generated-project-guide/#authentication-jwt-golang-jwtjwt","title":"Authentication: JWT (golang-jwt/jwt)","text":"<p>Flow complet:</p> <ol> <li>Register/Login \u2192 Serveur g\u00e9n\u00e8re Access Token (15min) + Refresh Token (7j)</li> <li>Client \u2192 Stocke les tokens, utilise Access Token pour chaque requ\u00eate</li> <li>Access Token expire \u2192 Client envoie Refresh Token</li> <li>Serveur \u2192 Valide Refresh Token, g\u00e9n\u00e8re nouveau Access Token</li> <li>Refresh Token expire \u2192 Client doit se re-login</li> </ol> <p>G\u00e9n\u00e9ration de tokens:</p> <pre><code>// Access token (courte dur\u00e9e)\naccessToken, err := jwt.GenerateAccessToken(userID, jwtSecret, 15*time.Minute)\n\n// Refresh token (longue dur\u00e9e)\nrefreshToken, err := jwt.GenerateRefreshToken(userID, jwtSecret, 7*24*time.Hour)\n</code></pre> <p>Validation:</p> <pre><code>claims, err := jwt.ParseToken(tokenString, jwtSecret)\nuserID := claims.UserID\n</code></pre>"},{"location":"generated-project-guide/#structure-des-repertoires-detaillee","title":"Structure des r\u00e9pertoires d\u00e9taill\u00e9e","text":""},{"location":"generated-project-guide/#cmdmaingo","title":"<code>/cmd/main.go</code>","text":"<p>R\u00f4le: Bootstrap de l'application.</p> <p>Contenu:</p> <pre><code>package main\n\nimport (\n    \"go.uber.org/fx\"\n    \"mon-projet/internal/domain/user\"\n    \"mon-projet/internal/infrastructure/database\"\n    \"mon-projet/internal/infrastructure/server\"\n    \"mon-projet/pkg/auth\"\n    \"mon-projet/pkg/config\"\n    \"mon-projet/pkg/logger\"\n)\n\nfunc main() {\n    fx.New(\n        logger.Module,\n        config.Module,\n        database.Module,\n        auth.Module,\n        user.Module,\n        server.Module,\n    ).Run()\n}\n</code></pre> <p>Principe: Composition de modules, pas de logique m\u00e9tier.</p>"},{"location":"generated-project-guide/#internalmodels","title":"<code>/internal/models</code>","text":"<p>Models: Entit\u00e9s de domaine partag\u00e9es utilis\u00e9es \u00e0 travers toute l'application.</p> <p>R\u00f4le: Centraliser les d\u00e9finitions des structures de donn\u00e9es (entities) pour \u00e9viter les d\u00e9pendances circulaires.</p>"},{"location":"generated-project-guide/#usergo","title":"<code>user.go</code>","text":"<p>D\u00e9finit les entit\u00e9s User, RefreshToken et AuthResponse:</p> <pre><code>package models\n\nimport (\n    \"time\"\n    \"gorm.io/gorm\"\n)\n\n// User represents the domain entity for a user\ntype User struct {\n    ID           uint           `gorm:\"primaryKey\" json:\"id\"`\n    Email        string         `gorm:\"uniqueIndex;not null\" json:\"email\"`\n    PasswordHash string         `gorm:\"not null\" json:\"-\"`\n    CreatedAt    time.Time      `gorm:\"autoCreateTime\" json:\"created_at\"`\n    UpdatedAt    time.Time      `gorm:\"autoUpdateTime\" json:\"updated_at\"`\n    DeletedAt    gorm.DeletedAt `gorm:\"index\" json:\"deleted_at,omitempty\"`\n}\n\n// RefreshToken represents a refresh token for session management\ntype RefreshToken struct {\n    ID        uint      `gorm:\"primaryKey\" json:\"id\"`\n    UserID    uint      `gorm:\"not null;index\" json:\"user_id\"`\n    Token     string    `gorm:\"uniqueIndex;not null\" json:\"token\"`\n    ExpiresAt time.Time `gorm:\"not null\" json:\"expires_at\"`\n    Revoked   bool      `gorm:\"not null;default:false\" json:\"revoked\"`\n    CreatedAt time.Time `gorm:\"autoCreateTime\" json:\"created_at\"`\n    UpdatedAt time.Time `gorm:\"autoUpdateTime\" json:\"updated_at\"`\n}\n\nfunc (rt *RefreshToken) IsExpired() bool {\n    return time.Now().After(rt.ExpiresAt)\n}\n\nfunc (rt *RefreshToken) IsRevoked() bool {\n    return rt.Revoked\n}\n\n// AuthResponse represents the authentication response with tokens\ntype AuthResponse struct {\n    AccessToken  string `json:\"access_token\"`\n    RefreshToken string `json:\"refresh_token\"`\n    ExpiresIn    int64  `json:\"expires_in\"`\n}\n</code></pre> <p>Principes:</p> <ul> <li>Entit\u00e9s GORM: Tags GORM pour configuration base de donn\u00e9es</li> <li>Serialization JSON: Tags json pour contr\u00f4ler l'API (ex: <code>json:\"-\"</code> cache PasswordHash)</li> <li>M\u00e9thodes utilitaires: IsExpired(), IsRevoked() pour la logique de validation</li> <li>Pas de d\u00e9pendances: Aucun import de domain ou interfaces</li> <li>Utilisable partout: Import\u00e9 par interfaces, domain, repository, handlers</li> </ul> <p>Pourquoi un package s\u00e9par\u00e9?</p> <ul> <li>\u00c9vite les cycles: Avant, <code>interfaces</code> \u2192 <code>domain/user</code> \u2192 <code>interfaces</code> (\u274c cycle!)</li> <li>Maintenant: <code>interfaces</code> \u2192 <code>models</code> \u2190 <code>domain/user</code> (\u2705 pas de cycle)</li> <li>Clart\u00e9: S\u00e9paration entre entities (models) et business logic (domain)</li> </ul>"},{"location":"generated-project-guide/#internaldomain","title":"<code>/internal/domain</code>","text":"<p>Domaine: Logique m\u00e9tier pure, ind\u00e9pendante de l'infrastructure.</p>"},{"location":"generated-project-guide/#errorsgo","title":"<code>errors.go</code>","text":"<p>D\u00e9finit les erreurs m\u00e9tier personnalis\u00e9es:</p> <pre><code>type DomainError struct {\n    Type    string\n    Message string\n    Code    string\n    Err     error\n}\n\nfunc NewNotFoundError(message, code string, err error) *DomainError\nfunc NewValidationError(message, code string, err error) *DomainError\nfunc NewConflictError(message, code string, err error) *DomainError\nfunc NewUnauthorizedError(message, code string, err error) *DomainError\n</code></pre> <p>Usage:</p> <pre><code>if user == nil {\n    return domain.NewNotFoundError(\"User not found\", \"USER_NOT_FOUND\", nil)\n}\n</code></pre>"},{"location":"generated-project-guide/#userservicego","title":"<code>user/service.go</code>","text":"<p>Logique m\u00e9tier:</p> <pre><code>package user\n\nimport (\n    \"context\"\n    \"mon-projet/internal/models\"\n    \"mon-projet/internal/interfaces\"\n)\n\ntype Service struct {\n    repo   interfaces.UserRepository\n    logger zerolog.Logger\n}\n\nfunc (s *Service) Register(ctx context.Context, email, password string) (*models.User, error)\nfunc (s *Service) Login(ctx context.Context, email, password string) (*models.User, error)\nfunc (s *Service) GetByID(ctx context.Context, id uint) (*models.User, error)\nfunc (s *Service) Update(ctx context.Context, id uint, email string) (*models.User, error)\nfunc (s *Service) Delete(ctx context.Context, id uint) error\n</code></pre> <p>Responsabilit\u00e9s:</p> <ul> <li>Validation m\u00e9tier</li> <li>Hashage de password (Register)</li> <li>V\u00e9rification de password (Login)</li> <li>Orchestration d'appels repository</li> <li>Utilise <code>models.User</code>: Importe le package models pour les entit\u00e9s</li> </ul>"},{"location":"generated-project-guide/#internaladapters","title":"<code>/internal/adapters</code>","text":"<p>Adapters: Connectent le domaine au monde ext\u00e9rieur.</p>"},{"location":"generated-project-guide/#handlersauth_handlergo","title":"<code>handlers/auth_handler.go</code>","text":"<p>Endpoints d'authentification:</p> <pre><code>type AuthHandler struct {\n    authService interfaces.AuthService\n    userService interfaces.UserService\n    jwtSecret   string\n    validate    *validator.Validate\n}\n\nfunc (h *AuthHandler) Register(c *fiber.Ctx) error\nfunc (h *AuthHandler) Login(c *fiber.Ctx) error\nfunc (h *AuthHandler) RefreshToken(c *fiber.Ctx) error\n</code></pre> <p>Pattern:</p> <ol> <li>Parse body JSON</li> <li>Validate avec validator</li> <li>Appeler service</li> <li>G\u00e9n\u00e9rer tokens (pour Login/Register)</li> <li>Retourner r\u00e9ponse</li> </ol> <p>Exemple Register:</p> <pre><code>func (h *AuthHandler) Register(c *fiber.Ctx) error {\n    var req RegisterRequest\n    if err := c.BodyParser(&amp;req); err != nil {\n        return err\n    }\n\n    if err := h.validate.Struct(req); err != nil {\n        return domain.NewValidationError(\"Invalid input\", \"VALIDATION_ERROR\", err)\n    }\n\n    user, err := h.userService.Register(c.Context(), req.Email, req.Password)\n    if err != nil {\n        return err\n    }\n\n    accessToken, _ := auth.GenerateAccessToken(user.ID, h.jwtSecret, 15*time.Minute)\n    refreshToken, _ := auth.GenerateRefreshToken(user.ID, h.jwtSecret, 168*time.Hour)\n\n    return c.Status(fiber.StatusCreated).JSON(fiber.Map{\n        \"status\": \"success\",\n        \"data\": fiber.Map{\n            \"access_token\":  accessToken,\n            \"refresh_token\": refreshToken,\n            \"token_type\":    \"Bearer\",\n            \"expires_in\":    900,\n        },\n    })\n}\n</code></pre>"},{"location":"generated-project-guide/#middlewareauth_middlewarego","title":"<code>middleware/auth_middleware.go</code>","text":"<p>V\u00e9rifie le JWT token:</p> <pre><code>type AuthMiddleware struct {\n    jwtSecret string\n}\n\nfunc (m *AuthMiddleware) Authenticate() fiber.Handler {\n    return func(c *fiber.Ctx) error {\n        // Extraire token du header Authorization\n        authHeader := c.Get(\"Authorization\")\n        if authHeader == \"\" {\n            return fiber.NewError(fiber.StatusUnauthorized, \"Missing authorization header\")\n        }\n\n        // Valider format \"Bearer &lt;token&gt;\"\n        parts := strings.Split(authHeader, \" \")\n        if len(parts) != 2 || parts[0] != \"Bearer\" {\n            return fiber.NewError(fiber.StatusUnauthorized, \"Invalid authorization format\")\n        }\n\n        // Parser et valider le token\n        claims, err := auth.ParseToken(parts[1], m.jwtSecret)\n        if err != nil {\n            return fiber.NewError(fiber.StatusUnauthorized, \"Invalid token\")\n        }\n\n        // Injecter user ID dans le contexte\n        c.Locals(\"user_id\", claims.UserID)\n\n        return c.Next()\n    }\n}\n</code></pre>"},{"location":"generated-project-guide/#middlewareerror_handlergo","title":"<code>middleware/error_handler.go</code>","text":"<p>Gestion centralis\u00e9e des erreurs:</p> <pre><code>func (h *ErrorHandler) Handle(c *fiber.Ctx, err error) error {\n    // DomainError \u2192 HTTP status appropri\u00e9\n    if domainErr, ok := err.(*domain.DomainError); ok {\n        switch domainErr.Type {\n        case \"not_found\":\n            return c.Status(fiber.StatusNotFound).JSON(fiber.Map{\n                \"status\": \"error\",\n                \"error\":  domainErr.Message,\n                \"code\":   domainErr.Code,\n            })\n        case \"validation\":\n            return c.Status(fiber.StatusBadRequest).JSON(...)\n        case \"unauthorized\":\n            return c.Status(fiber.StatusUnauthorized).JSON(...)\n        case \"conflict\":\n            return c.Status(fiber.StatusConflict).JSON(...)\n        }\n    }\n\n    // Erreur g\u00e9n\u00e9rique\n    return c.Status(fiber.StatusInternalServerError).JSON(...)\n}\n</code></pre> <p>Avantage: Les handlers n'ont pas besoin de g\u00e9rer les status HTTP, juste retourner des DomainError.</p>"},{"location":"generated-project-guide/#repositoryuser_repositorygo","title":"<code>repository/user_repository.go</code>","text":"<p>Impl\u00e9mentation du repository avec GORM:</p> <pre><code>type userRepositoryGORM struct {\n    db *gorm.DB\n}\n\nfunc (r *userRepositoryGORM) Create(ctx context.Context, user *models.User) error {\n    return r.db.WithContext(ctx).Create(user).Error\n}\n\nfunc (r *userRepositoryGORM) FindByEmail(ctx context.Context, email string) (*models.User, error) {\n    var user models.User\n    err := r.db.WithContext(ctx).Where(\"email = ?\", email).First(&amp;user).Error\n    if err == gorm.ErrRecordNotFound {\n        return nil, domain.NewNotFoundError(\"User not found\", \"USER_NOT_FOUND\", err)\n    }\n    return &amp;user, err\n}\n</code></pre>"},{"location":"generated-project-guide/#internalinfrastructure","title":"<code>/internal/infrastructure</code>","text":"<p>Infrastructure: Configuration DB et serveur.</p>"},{"location":"generated-project-guide/#databasedatabasego","title":"<code>database/database.go</code>","text":"<pre><code>func NewDatabase(config *config.Config, logger zerolog.Logger) (*gorm.DB, error) {\n    dsn := fmt.Sprintf(\"host=%s user=%s password=%s dbname=%s port=%s sslmode=%s\",\n        config.DBHost, config.DBUser, config.DBPassword,\n        config.DBName, config.DBPort, config.DBSSLMode)\n\n    db, err := gorm.Open(postgres.Open(dsn), &amp;gorm.Config{})\n\n    // AutoMigrate\n    db.AutoMigrate(&amp;models.User{}, &amp;models.RefreshToken{})\n\n    return db, nil\n}\n</code></pre>"},{"location":"generated-project-guide/#serverservergo","title":"<code>server/server.go</code>","text":"<p>Le serveur cr\u00e9e l'application Fiber et g\u00e8re le lifecycle. Les routes sont enregistr\u00e9es via <code>server.Module</code> qui invoque <code>httpRoutes.RegisterRoutes()</code> avec <code>fx.Invoke</code>.</p> <pre><code>// Module provides the Fiber server dependency via fx\nvar Module = fx.Module(\"server\",\n    fx.Provide(NewServer),\n    fx.Invoke(registerHooks),\n    fx.Invoke(httpRoutes.RegisterRoutes),  // Routes centralis\u00e9es\n)\n\nfunc NewServer(logger zerolog.Logger, db *gorm.DB) *fiber.App {\n    app := fiber.New(fiber.Config{\n        AppName:      \"mon-projet\",\n        ErrorHandler: middleware.ErrorHandler,\n    })\n\n    logger.Info().Msg(\"Fiber server initialized with centralized error handler\")\n\n    return app\n}\n\n// registerHooks registers lifecycle hooks for server startup and shutdown\nfunc registerHooks(lifecycle fx.Lifecycle, app *fiber.App, logger zerolog.Logger) {\n    lifecycle.Append(fx.Hook{\n        OnStart: func(ctx context.Context) error {\n            port := config.GetEnv(\"APP_PORT\", \"8080\")\n            logger.Info().Str(\"port\", port).Msg(\"Starting Fiber server\")\n\n            go func() {\n                if err := app.Listen(\":\" + port); err != nil {\n                    logger.Error().Err(err).Msg(\"Server stopped unexpectedly\")\n                }\n            }()\n\n            return nil\n        },\n        OnStop: func(ctx context.Context) error {\n            logger.Info().Msg(\"Shutting down Fiber server gracefully\")\n            return app.ShutdownWithContext(ctx)\n        },\n    })\n}\n</code></pre>"},{"location":"generated-project-guide/#httproutesgo","title":"<code>http/routes.go</code>","text":"<p>Fichier centralis\u00e9 pour toutes les routes de l'application :</p> <pre><code>func RegisterRoutes(\n    app *fiber.App,\n    authHandler *handlers.AuthHandler,\n    userHandler *handlers.UserHandler,\n    authMiddleware fiber.Handler,\n) {\n    // Health &amp; Swagger\n    RegisterHealthRoutes(app)\n    app.Get(\"/swagger/*\", swagger.WrapHandler)\n\n    // API v1\n    api := app.Group(\"/api\")\n    v1 := api.Group(\"/v1\")\n\n    // Auth routes (public)\n    auth := v1.Group(\"/auth\")\n    auth.Post(\"/register\", authHandler.Register)\n    auth.Post(\"/login\", authHandler.Login)\n    auth.Post(\"/refresh\", authHandler.Refresh)\n\n    // User routes (protected)\n    users := v1.Group(\"/users\", authMiddleware)\n    users.Get(\"/me\", userHandler.GetMe)\n    users.Get(\"\", userHandler.GetAllUsers)\n    users.Put(\"/:id\", userHandler.UpdateUser)\n    users.Delete(\"/:id\", userHandler.DeleteUser)\n}\n</code></pre>"},{"location":"generated-project-guide/#pkg","title":"<code>/pkg</code>","text":"<p>Packages r\u00e9utilisables: Peuvent \u00eatre import\u00e9s par d'autres projets.</p>"},{"location":"generated-project-guide/#authjwtgo","title":"<code>auth/jwt.go</code>","text":"<pre><code>func GenerateAccessToken(userID uint, secret string, expiry time.Duration) (string, error) {\n    claims := &amp;Claims{\n        UserID: userID,\n        RegisteredClaims: jwt.RegisteredClaims{\n            ExpiresAt: jwt.NewNumericDate(time.Now().Add(expiry)),\n            IssuedAt:  jwt.NewNumericDate(time.Now()),\n        },\n    }\n\n    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\n    return token.SignedString([]byte(secret))\n}\n</code></pre>"},{"location":"generated-project-guide/#configuration","title":"Configuration","text":""},{"location":"generated-project-guide/#variables-denvironnement","title":"Variables d'environnement","text":"<p>Le fichier <code>.env</code> contient toute la configuration:</p> <pre><code># Application\nAPP_NAME=mon-projet\nAPP_ENV=development\nAPP_PORT=8080\n\n# Database\nDB_HOST=localhost\nDB_PORT=5432\nDB_USER=postgres\nDB_PASSWORD=postgres\nDB_NAME=mon-projet\nDB_SSLMODE=disable\n\n# JWT\nJWT_SECRET=          # \u00c0 REMPLIR!\nJWT_EXPIRY=15m\nREFRESH_TOKEN_EXPIRY=168h\n</code></pre>"},{"location":"generated-project-guide/#generer-un-jwt_secret-securise","title":"G\u00e9n\u00e9rer un JWT_SECRET s\u00e9curis\u00e9","text":"<p>CRITIQUE: G\u00e9n\u00e9rez toujours un secret fort:</p> <pre><code>openssl rand -base64 32\n</code></pre> <p>Exemple de r\u00e9sultat: <pre><code>XqR7nP3vY2kL9wH4sT6mU8jC1bN5aD0f\n</code></pre></p> <p>Ajoutez-le dans <code>.env</code>: <pre><code>JWT_SECRET=XqR7nP3vY2kL9wH4sT6mU8jC1bN5aD0f\n</code></pre></p>"},{"location":"generated-project-guide/#configuration-par-environnement","title":"Configuration par environnement","text":""},{"location":"generated-project-guide/#development","title":"Development","text":"<pre><code>APP_ENV=development\nDB_HOST=localhost\nDB_SSLMODE=disable\n</code></pre>"},{"location":"generated-project-guide/#staging","title":"Staging","text":"<pre><code>APP_ENV=staging\nDB_HOST=staging-db.example.com\nDB_SSLMODE=require\nJWT_SECRET=&lt;secret-depuis-vault&gt;\n</code></pre>"},{"location":"generated-project-guide/#production","title":"Production","text":"<pre><code>APP_ENV=production\nDB_HOST=prod-db.example.com\nDB_SSLMODE=require\nDB_PASSWORD=&lt;secret-depuis-secrets-manager&gt;\nJWT_SECRET=&lt;secret-depuis-secrets-manager&gt;\n</code></pre> <p>Best practice: Utiliser des secrets managers:</p> <ul> <li>AWS: Secrets Manager, Parameter Store</li> <li>GCP: Secret Manager</li> <li>Kubernetes: Secrets</li> <li>HashiCorp: Vault</li> </ul>"},{"location":"generated-project-guide/#configuration-postgresql","title":"Configuration PostgreSQL","text":""},{"location":"generated-project-guide/#option-1-postgresql-local","title":"Option 1: PostgreSQL local","text":"<p>macOS (Homebrew):</p> <pre><code>brew install postgresql@16\nbrew services start postgresql@16\ncreatedb mon-projet\n</code></pre> <p>Linux (apt):</p> <pre><code>sudo apt update\nsudo apt install postgresql postgresql-contrib\nsudo systemctl start postgresql\nsudo -u postgres createdb mon-projet\n</code></pre>"},{"location":"generated-project-guide/#option-2-docker","title":"Option 2: Docker","text":"<pre><code>docker run -d \\\n  --name postgres \\\n  -e POSTGRES_DB=mon-projet \\\n  -e POSTGRES_USER=postgres \\\n  -e POSTGRES_PASSWORD=postgres \\\n  -p 5432:5432 \\\n  postgres:16-alpine\n</code></pre>"},{"location":"generated-project-guide/#option-3-docker-compose","title":"Option 3: Docker Compose","text":"<p>Si un <code>docker-compose.yml</code> est g\u00e9n\u00e9r\u00e9:</p> <pre><code>version: '3.8'\n\nservices:\n  postgres:\n    image: postgres:16-alpine\n    environment:\n      POSTGRES_DB: mon-projet\n      POSTGRES_USER: postgres\n      POSTGRES_PASSWORD: postgres\n    ports:\n      - \"5432:5432\"\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n\nvolumes:\n  postgres_data:\n</code></pre> <p>Lancer:</p> <pre><code>docker-compose up -d postgres\n</code></pre>"},{"location":"generated-project-guide/#verification-de-connexion","title":"V\u00e9rification de connexion","text":"<pre><code># Avec psql\npsql -h localhost -U postgres -d mon-projet\n\n# Ou tester depuis l'app\nmake run\n# V\u00e9rifier les logs: \"Database connected successfully\"\n</code></pre>"},{"location":"generated-project-guide/#developpement","title":"D\u00e9veloppement","text":""},{"location":"generated-project-guide/#workflow-quotidien","title":"Workflow quotidien","text":"<p>1. Lancer la base de donn\u00e9es</p> <pre><code># Docker\ndocker start postgres\n# ou\ndocker-compose up -d postgres\n\n# Local\nbrew services start postgresql  # macOS\nsudo systemctl start postgresql # Linux\n</code></pre> <p>2. Lancer l'application</p> <pre><code>make run\n</code></pre> <p>Ou avec hot-reload (si <code>air</code> install\u00e9):</p> <pre><code># Installer air\ngo install github.com/cosmtrek/air@latest\n\n# Lancer avec hot-reload\nair\n</code></pre> <p>3. D\u00e9velopper</p> <ul> <li>Modifier le code</li> <li>Sauvegarder (auto-reload avec air)</li> <li>V\u00e9rifier les logs</li> </ul> <p>4. Tester</p> <pre><code># Tests unitaires\nmake test\n\n# Tests avec coverage\nmake test-coverage\n\n# Ouvrir le rapport\nopen coverage.html\n</code></pre> <p>5. Linter</p> <pre><code>make lint\n</code></pre>"},{"location":"generated-project-guide/#commandes-makefile","title":"Commandes Makefile","text":"Commande Description <code>make help</code> Afficher l'aide <code>make run</code> Lancer l'app <code>make build</code> Build binaire <code>make test</code> Tests avec race detector <code>make test-coverage</code> Tests + rapport HTML <code>make lint</code> golangci-lint <code>make clean</code> Nettoyer artifacts <code>make docker-build</code> Build image Docker <code>make docker-run</code> Run conteneur Docker"},{"location":"generated-project-guide/#ajouter-une-nouvelle-fonctionnalite","title":"Ajouter une nouvelle fonctionnalite","text":"<p>Cette section vous guide pas a pas pour ajouter une nouvelle entite/fonctionnalite en respectant l'architecture hexagonale.</p>"},{"location":"generated-project-guide/#vue-densemble-des-9-etapes","title":"Vue d'ensemble des 9 etapes","text":"<pre><code>flowchart LR\n    A[\"1. Model\"] --&gt; B[\"2. Interface\"]\n    B --&gt; C[\"3. Repository\"]\n    B --&gt; D[\"4. Service\"]\n    C --&gt; E[\"5. Module fx\"]\n    D --&gt; E\n    D --&gt; F[\"6. Handler\"]\n    F --&gt; G[\"7. Routes\"]\n    A --&gt; H[\"8. Migration\"]\n    E --&gt; I[\"9. Bootstrap\"]\n    G --&gt; I</code></pre>"},{"location":"generated-project-guide/#checklist-rapide","title":"Checklist rapide","text":"<p>Utilisez cette checklist pour ne rien oublier :</p> Etape Fichier a creer/modifier Depend de Status 1. Model <code>internal/models/&lt;entity&gt;.go</code> - [ ] 2. Interface <code>internal/interfaces/&lt;entity&gt;_repository.go</code> Etape 1 [ ] 3. Repository <code>internal/adapters/repository/&lt;entity&gt;_repository.go</code> Etapes 1, 2 [ ] 4. Service <code>internal/domain/&lt;entity&gt;/service.go</code> Etapes 1, 2 [ ] 5. Module fx <code>internal/domain/&lt;entity&gt;/module.go</code> Etapes 3, 4 [ ] 6. Handler <code>internal/adapters/handlers/&lt;entity&gt;_handler.go</code> Etapes 1, 4 [ ] 7. Routes <code>internal/infrastructure/server/server.go</code> (modifier) Etape 6 [ ] 8. Migration <code>internal/infrastructure/database/database.go</code> (modifier) Etape 1 [ ] 9. Bootstrap <code>cmd/main.go</code> (modifier) Etape 5 [ ]"},{"location":"generated-project-guide/#diagramme-des-dependances-entre-fichiers","title":"Diagramme des dependances entre fichiers","text":"<p>Ce diagramme montre l'ordre de creation des fichiers et leurs dependances :</p> <pre><code>flowchart TD\n    subgraph Step1[\"Etape 1 - Foundation\"]\n        Model[\"models/product.go&lt;br/&gt;Entite GORM\"]\n    end\n\n    subgraph Step2[\"Etape 2 - Abstraction\"]\n        Interface[\"interfaces/product_repository.go&lt;br/&gt;Port (contrat)\"]\n    end\n\n    subgraph Step34[\"Etapes 3 et 4 - Implementation\"]\n        Repo[\"repository/product_repository.go&lt;br/&gt;Adapter GORM\"]\n        Service[\"domain/product/service.go&lt;br/&gt;Business Logic\"]\n    end\n\n    subgraph Step5[\"Etape 5 - DI\"]\n        Module[\"domain/product/module.go&lt;br/&gt;fx.Module\"]\n    end\n\n    subgraph Step6[\"Etape 6 - HTTP\"]\n        Handler[\"handlers/product_handler.go&lt;br/&gt;REST endpoints\"]\n    end\n\n    subgraph Step789[\"Etapes 7, 8, 9 - Integration\"]\n        Routes[\"server/server.go&lt;br/&gt;Ajouter routes\"]\n        Migration[\"database/database.go&lt;br/&gt;AutoMigrate\"]\n        Main[\"cmd/main.go&lt;br/&gt;Ajouter module\"]\n    end\n\n    Model --&gt; Interface\n    Model --&gt; Repo\n    Model --&gt; Service\n    Interface --&gt; Repo\n    Interface --&gt; Service\n    Repo --&gt; Module\n    Service --&gt; Module\n    Service --&gt; Handler\n    Model --&gt; Handler\n    Handler --&gt; Routes\n    Module --&gt; Main\n    Routes --&gt; Main\n    Model --&gt; Migration</code></pre>"},{"location":"generated-project-guide/#exemple-complet-entite-product","title":"Exemple complet : Entite Product","text":"<p>Nous allons creer une entite <code>Product</code> complete avec CRUD. Suivez chaque etape dans l'ordre.</p> <p>Conseil : Remplacez <code>mon-projet</code> par le nom de votre projet dans tous les imports.</p>"},{"location":"generated-project-guide/#etape-1-creer-le-model-entite","title":"Etape 1 : Creer le Model (Entite)","text":"<p>Fichier a creer : <code>internal/models/product.go</code></p> <pre><code>package models\n\nimport (\n    \"time\"\n\n    \"gorm.io/gorm\"\n)\n\n// Product represents a product in the catalog\ntype Product struct {\n    ID          uint           `gorm:\"primaryKey\" json:\"id\"`\n    Name        string         `gorm:\"not null;size:255\" json:\"name\"`\n    Description string         `gorm:\"type:text\" json:\"description\"`\n    Price       float64        `gorm:\"not null\" json:\"price\"`\n    Stock       int            `gorm:\"default:0\" json:\"stock\"`\n    SKU         string         `gorm:\"uniqueIndex;size:100\" json:\"sku\"`\n    Active      bool           `gorm:\"default:true\" json:\"active\"`\n    CreatedAt   time.Time      `gorm:\"autoCreateTime\" json:\"created_at\"`\n    UpdatedAt   time.Time      `gorm:\"autoUpdateTime\" json:\"updated_at\"`\n    DeletedAt   gorm.DeletedAt `gorm:\"index\" json:\"deleted_at,omitempty\"`\n}\n\n// ProductResponse is the DTO for API responses (controls what is exposed)\ntype ProductResponse struct {\n    ID          uint    `json:\"id\"`\n    Name        string  `json:\"name\"`\n    Description string  `json:\"description\"`\n    Price       float64 `json:\"price\"`\n    Stock       int     `json:\"stock\"`\n    SKU         string  `json:\"sku\"`\n    Active      bool    `json:\"active\"`\n}\n\n// ToResponse converts Product entity to ProductResponse DTO\nfunc (p *Product) ToResponse() ProductResponse {\n    return ProductResponse{\n        ID:          p.ID,\n        Name:        p.Name,\n        Description: p.Description,\n        Price:       p.Price,\n        Stock:       p.Stock,\n        SKU:         p.SKU,\n        Active:      p.Active,\n    }\n}\n</code></pre> <p>Pourquoi ? - Les entites sont centralisees dans <code>models/</code> pour eviter les dependances circulaires - Tags GORM pour la configuration de la base de donnees - Tags JSON pour controler la serialisation API - DTO separe (<code>ProductResponse</code>) pour controler ce qui est expose a l'API</p>"},{"location":"generated-project-guide/#etape-2-definir-linterface-port","title":"Etape 2 : Definir l'Interface (Port)","text":"<p>Fichier a creer : <code>internal/interfaces/product_repository.go</code></p> <pre><code>package interfaces\n\nimport (\n    \"context\"\n\n    \"mon-projet/internal/models\"\n)\n\n// ProductRepository defines the contract for product data access\n// This is the \"Port\" in hexagonal architecture\ntype ProductRepository interface {\n    Create(ctx context.Context, product *models.Product) error\n    FindByID(ctx context.Context, id uint) (*models.Product, error)\n    FindBySKU(ctx context.Context, sku string) (*models.Product, error)\n    FindAll(ctx context.Context, limit, offset int) ([]*models.Product, error)\n    FindActive(ctx context.Context) ([]*models.Product, error)\n    Update(ctx context.Context, product *models.Product) error\n    Delete(ctx context.Context, id uint) error\n    Count(ctx context.Context) (int64, error)\n}\n\n// ProductService defines the contract for product business logic\ntype ProductService interface {\n    Create(ctx context.Context, name, description, sku string, price float64, stock int) (*models.Product, error)\n    GetByID(ctx context.Context, id uint) (*models.Product, error)\n    GetAll(ctx context.Context, page, pageSize int) ([]*models.Product, int64, error)\n    Update(ctx context.Context, id uint, name, description string, price float64, stock int, active bool) (*models.Product, error)\n    Delete(ctx context.Context, id uint) error\n    UpdateStock(ctx context.Context, id uint, quantity int) error\n}\n</code></pre> <p>Pourquoi ? - Abstraction complete : le domain ne connait pas GORM - Contrat clair : toutes les operations disponibles sont definies - Testable : facile a mocker pour les tests unitaires</p>"},{"location":"generated-project-guide/#etape-3-implementer-le-repository-adapter","title":"Etape 3 : Implementer le Repository (Adapter)","text":"<p>Fichier a creer : <code>internal/adapters/repository/product_repository.go</code></p> <pre><code>package repository\n\nimport (\n    \"context\"\n\n    \"gorm.io/gorm\"\n\n    \"mon-projet/internal/domain\"\n    \"mon-projet/internal/interfaces\"\n    \"mon-projet/internal/models\"\n)\n\ntype productRepositoryGORM struct {\n    db *gorm.DB\n}\n\n// NewProductRepository creates a new product repository\nfunc NewProductRepository(db *gorm.DB) interfaces.ProductRepository {\n    return &amp;productRepositoryGORM{db: db}\n}\n\nfunc (r *productRepositoryGORM) Create(ctx context.Context, product *models.Product) error {\n    return r.db.WithContext(ctx).Create(product).Error\n}\n\nfunc (r *productRepositoryGORM) FindByID(ctx context.Context, id uint) (*models.Product, error) {\n    var product models.Product\n    err := r.db.WithContext(ctx).First(&amp;product, id).Error\n    if err == gorm.ErrRecordNotFound {\n        return nil, domain.NewNotFoundError(\"Product not found\", \"PRODUCT_NOT_FOUND\", err)\n    }\n    return &amp;product, err\n}\n\nfunc (r *productRepositoryGORM) FindBySKU(ctx context.Context, sku string) (*models.Product, error) {\n    var product models.Product\n    err := r.db.WithContext(ctx).Where(\"sku = ?\", sku).First(&amp;product).Error\n    if err == gorm.ErrRecordNotFound {\n        return nil, domain.NewNotFoundError(\"Product not found\", \"PRODUCT_NOT_FOUND\", err)\n    }\n    return &amp;product, err\n}\n\nfunc (r *productRepositoryGORM) FindAll(ctx context.Context, limit, offset int) ([]*models.Product, error) {\n    var products []*models.Product\n    err := r.db.WithContext(ctx).\n        Limit(limit).\n        Offset(offset).\n        Order(\"created_at DESC\").\n        Find(&amp;products).Error\n    return products, err\n}\n\nfunc (r *productRepositoryGORM) FindActive(ctx context.Context) ([]*models.Product, error) {\n    var products []*models.Product\n    err := r.db.WithContext(ctx).Where(\"active = ?\", true).Find(&amp;products).Error\n    return products, err\n}\n\nfunc (r *productRepositoryGORM) Update(ctx context.Context, product *models.Product) error {\n    return r.db.WithContext(ctx).Save(product).Error\n}\n\nfunc (r *productRepositoryGORM) Delete(ctx context.Context, id uint) error {\n    return r.db.WithContext(ctx).Delete(&amp;models.Product{}, id).Error\n}\n\nfunc (r *productRepositoryGORM) Count(ctx context.Context) (int64, error) {\n    var count int64\n    err := r.db.WithContext(ctx).Model(&amp;models.Product{}).Count(&amp;count).Error\n    return count, err\n}\n</code></pre> <p>Points cles : - Implemente l'interface <code>ProductRepository</code> - Utilise <code>WithContext(ctx)</code> pour la propagation du contexte - Convertit <code>gorm.ErrRecordNotFound</code> en <code>DomainError</code></p>"},{"location":"generated-project-guide/#etape-4-creer-le-service-domainbusiness-logic","title":"Etape 4 : Creer le Service (Domain/Business Logic)","text":"<p>Creer le dossier : <pre><code>mkdir -p internal/domain/product\n</code></pre></p> <p>Fichier a creer : <code>internal/domain/product/service.go</code></p> <pre><code>package product\n\nimport (\n    \"context\"\n    \"fmt\"\n\n    \"github.com/rs/zerolog\"\n\n    \"mon-projet/internal/domain\"\n    \"mon-projet/internal/interfaces\"\n    \"mon-projet/internal/models\"\n)\n\n// Service handles product business logic\ntype Service struct {\n    repo   interfaces.ProductRepository\n    logger zerolog.Logger\n}\n\n// NewService creates a new product service\nfunc NewService(repo interfaces.ProductRepository, logger zerolog.Logger) *Service {\n    return &amp;Service{\n        repo:   repo,\n        logger: logger.With().Str(\"service\", \"product\").Logger(),\n    }\n}\n\n// Create creates a new product with business validation\nfunc (s *Service) Create(ctx context.Context, name, description, sku string, price float64, stock int) (*models.Product, error) {\n    // Business validation\n    if price &lt;= 0 {\n        return nil, domain.NewValidationError(\"Price must be greater than 0\", \"INVALID_PRICE\", nil)\n    }\n    if stock &lt; 0 {\n        return nil, domain.NewValidationError(\"Stock cannot be negative\", \"INVALID_STOCK\", nil)\n    }\n\n    // Check SKU uniqueness (business rule)\n    existing, err := s.repo.FindBySKU(ctx, sku)\n    if err == nil &amp;&amp; existing != nil {\n        return nil, domain.NewConflictError(\"Product with this SKU already exists\", \"SKU_EXISTS\", nil)\n    }\n\n    product := &amp;models.Product{\n        Name:        name,\n        Description: description,\n        SKU:         sku,\n        Price:       price,\n        Stock:       stock,\n        Active:      true,\n    }\n\n    if err := s.repo.Create(ctx, product); err != nil {\n        s.logger.Error().Err(err).Str(\"sku\", sku).Msg(\"Failed to create product\")\n        return nil, fmt.Errorf(\"failed to create product: %w\", err)\n    }\n\n    s.logger.Info().\n        Uint(\"product_id\", product.ID).\n        Str(\"sku\", sku).\n        Msg(\"Product created successfully\")\n\n    return product, nil\n}\n\n// GetByID retrieves a product by its ID\nfunc (s *Service) GetByID(ctx context.Context, id uint) (*models.Product, error) {\n    return s.repo.FindByID(ctx, id)\n}\n\n// GetAll retrieves all products with pagination\nfunc (s *Service) GetAll(ctx context.Context, page, pageSize int) ([]*models.Product, int64, error) {\n    // Validate and set defaults for pagination\n    if page &lt; 1 {\n        page = 1\n    }\n    if pageSize &lt; 1 || pageSize &gt; 100 {\n        pageSize = 20 // Default page size\n    }\n\n    offset := (page - 1) * pageSize\n\n    products, err := s.repo.FindAll(ctx, pageSize, offset)\n    if err != nil {\n        return nil, 0, fmt.Errorf(\"failed to fetch products: %w\", err)\n    }\n\n    total, err := s.repo.Count(ctx)\n    if err != nil {\n        return nil, 0, fmt.Errorf(\"failed to count products: %w\", err)\n    }\n\n    return products, total, nil\n}\n\n// Update updates an existing product\nfunc (s *Service) Update(ctx context.Context, id uint, name, description string, price float64, stock int, active bool) (*models.Product, error) {\n    // Fetch existing product\n    product, err := s.repo.FindByID(ctx, id)\n    if err != nil {\n        return nil, err\n    }\n\n    // Business validation\n    if price &lt;= 0 {\n        return nil, domain.NewValidationError(\"Price must be greater than 0\", \"INVALID_PRICE\", nil)\n    }\n    if stock &lt; 0 {\n        return nil, domain.NewValidationError(\"Stock cannot be negative\", \"INVALID_STOCK\", nil)\n    }\n\n    // Update fields\n    product.Name = name\n    product.Description = description\n    product.Price = price\n    product.Stock = stock\n    product.Active = active\n\n    if err := s.repo.Update(ctx, product); err != nil {\n        s.logger.Error().Err(err).Uint(\"product_id\", id).Msg(\"Failed to update product\")\n        return nil, fmt.Errorf(\"failed to update product: %w\", err)\n    }\n\n    s.logger.Info().Uint(\"product_id\", id).Msg(\"Product updated successfully\")\n    return product, nil\n}\n\n// Delete soft-deletes a product\nfunc (s *Service) Delete(ctx context.Context, id uint) error {\n    // Verify product exists\n    _, err := s.repo.FindByID(ctx, id)\n    if err != nil {\n        return err\n    }\n\n    if err := s.repo.Delete(ctx, id); err != nil {\n        s.logger.Error().Err(err).Uint(\"product_id\", id).Msg(\"Failed to delete product\")\n        return fmt.Errorf(\"failed to delete product: %w\", err)\n    }\n\n    s.logger.Info().Uint(\"product_id\", id).Msg(\"Product deleted successfully\")\n    return nil\n}\n\n// UpdateStock adjusts the stock quantity (positive or negative)\nfunc (s *Service) UpdateStock(ctx context.Context, id uint, quantity int) error {\n    product, err := s.repo.FindByID(ctx, id)\n    if err != nil {\n        return err\n    }\n\n    newStock := product.Stock + quantity\n    if newStock &lt; 0 {\n        return domain.NewValidationError(\"Insufficient stock\", \"INSUFFICIENT_STOCK\", nil)\n    }\n\n    product.Stock = newStock\n    if err := s.repo.Update(ctx, product); err != nil {\n        return fmt.Errorf(\"failed to update stock: %w\", err)\n    }\n\n    s.logger.Info().\n        Uint(\"product_id\", id).\n        Int(\"quantity_change\", quantity).\n        Int(\"new_stock\", newStock).\n        Msg(\"Stock updated\")\n\n    return nil\n}\n</code></pre> <p>Points cles : - Toute la logique metier est ici (validation, regles business) - Utilise les <code>DomainError</code> pour les erreurs metier - Logging structure avec contexte - Le service ne connait que les interfaces, pas les implementations</p>"},{"location":"generated-project-guide/#etape-5-creer-le-module-fx-dependency-injection","title":"Etape 5 : Creer le Module fx (Dependency Injection)","text":"<p>Fichier a creer : <code>internal/domain/product/module.go</code></p> <pre><code>package product\n\nimport (\n    \"go.uber.org/fx\"\n\n    \"mon-projet/internal/adapters/handlers\"\n    \"mon-projet/internal/adapters/repository\"\n    \"mon-projet/internal/interfaces\"\n)\n\n// Module provides all product-related dependencies\nvar Module = fx.Module(\"product\",\n    fx.Provide(\n        // Repository: concrete -&gt; interface\n        fx.Annotate(\n            repository.NewProductRepository,\n            fx.As(new(interfaces.ProductRepository)),\n        ),\n        // Service: concrete -&gt; interface\n        fx.Annotate(\n            NewService,\n            fx.As(new(interfaces.ProductService)),\n        ),\n        // Handler\n        handlers.NewProductHandler,\n    ),\n)\n</code></pre> <p>Pourquoi fx.Annotate ? - Permet de fournir une implementation concrete tout en exposant l'interface - Facilite le remplacement des implementations (tests, mock, autre DB)</p>"},{"location":"generated-project-guide/#etape-6-creer-le-handler-http-adapter","title":"Etape 6 : Creer le Handler (HTTP Adapter)","text":"<p>Fichier a creer : <code>internal/adapters/handlers/product_handler.go</code></p> <pre><code>package handlers\n\nimport (\n    \"strconv\"\n\n    \"github.com/go-playground/validator/v10\"\n    \"github.com/gofiber/fiber/v2\"\n\n    \"mon-projet/internal/domain\"\n    \"mon-projet/internal/interfaces\"\n)\n\n// ProductHandler handles HTTP requests for products\ntype ProductHandler struct {\n    service  interfaces.ProductService\n    validate *validator.Validate\n}\n\n// NewProductHandler creates a new product handler\nfunc NewProductHandler(service interfaces.ProductService) *ProductHandler {\n    return &amp;ProductHandler{\n        service:  service,\n        validate: validator.New(),\n    }\n}\n\n// Request DTOs with validation tags\ntype CreateProductRequest struct {\n    Name        string  `json:\"name\" validate:\"required,max=255\"`\n    Description string  `json:\"description\" validate:\"max=1000\"`\n    SKU         string  `json:\"sku\" validate:\"required,max=100\"`\n    Price       float64 `json:\"price\" validate:\"required,gt=0\"`\n    Stock       int     `json:\"stock\" validate:\"gte=0\"`\n}\n\ntype UpdateProductRequest struct {\n    Name        string  `json:\"name\" validate:\"required,max=255\"`\n    Description string  `json:\"description\" validate:\"max=1000\"`\n    Price       float64 `json:\"price\" validate:\"required,gt=0\"`\n    Stock       int     `json:\"stock\" validate:\"gte=0\"`\n    Active      bool    `json:\"active\"`\n}\n\n// Create handles POST /api/v1/products\nfunc (h *ProductHandler) Create(c *fiber.Ctx) error {\n    var req CreateProductRequest\n    if err := c.BodyParser(&amp;req); err != nil {\n        return domain.NewValidationError(\"Invalid request body\", \"INVALID_BODY\", err)\n    }\n\n    if err := h.validate.Struct(req); err != nil {\n        return domain.NewValidationError(\"Validation failed\", \"VALIDATION_ERROR\", err)\n    }\n\n    product, err := h.service.Create(\n        c.Context(),\n        req.Name,\n        req.Description,\n        req.SKU,\n        req.Price,\n        req.Stock,\n    )\n    if err != nil {\n        return err\n    }\n\n    return c.Status(fiber.StatusCreated).JSON(fiber.Map{\n        \"status\": \"success\",\n        \"data\":   product.ToResponse(),\n    })\n}\n\n// GetByID handles GET /api/v1/products/:id\nfunc (h *ProductHandler) GetByID(c *fiber.Ctx) error {\n    id, err := strconv.ParseUint(c.Params(\"id\"), 10, 32)\n    if err != nil {\n        return domain.NewValidationError(\"Invalid product ID\", \"INVALID_ID\", err)\n    }\n\n    product, err := h.service.GetByID(c.Context(), uint(id))\n    if err != nil {\n        return err\n    }\n\n    return c.JSON(fiber.Map{\n        \"status\": \"success\",\n        \"data\":   product.ToResponse(),\n    })\n}\n\n// List handles GET /api/v1/products\nfunc (h *ProductHandler) List(c *fiber.Ctx) error {\n    page, _ := strconv.Atoi(c.Query(\"page\", \"1\"))\n    pageSize, _ := strconv.Atoi(c.Query(\"page_size\", \"20\"))\n\n    products, total, err := h.service.GetAll(c.Context(), page, pageSize)\n    if err != nil {\n        return err\n    }\n\n    // Convert to response DTOs\n    responses := make([]interface{}, len(products))\n    for i, p := range products {\n        responses[i] = p.ToResponse()\n    }\n\n    totalPages := (total + int64(pageSize) - 1) / int64(pageSize)\n\n    return c.JSON(fiber.Map{\n        \"status\": \"success\",\n        \"data\":   responses,\n        \"meta\": fiber.Map{\n            \"page\":        page,\n            \"page_size\":   pageSize,\n            \"total\":       total,\n            \"total_pages\": totalPages,\n        },\n    })\n}\n\n// Update handles PUT /api/v1/products/:id\nfunc (h *ProductHandler) Update(c *fiber.Ctx) error {\n    id, err := strconv.ParseUint(c.Params(\"id\"), 10, 32)\n    if err != nil {\n        return domain.NewValidationError(\"Invalid product ID\", \"INVALID_ID\", err)\n    }\n\n    var req UpdateProductRequest\n    if err := c.BodyParser(&amp;req); err != nil {\n        return domain.NewValidationError(\"Invalid request body\", \"INVALID_BODY\", err)\n    }\n\n    if err := h.validate.Struct(req); err != nil {\n        return domain.NewValidationError(\"Validation failed\", \"VALIDATION_ERROR\", err)\n    }\n\n    product, err := h.service.Update(\n        c.Context(),\n        uint(id),\n        req.Name,\n        req.Description,\n        req.Price,\n        req.Stock,\n        req.Active,\n    )\n    if err != nil {\n        return err\n    }\n\n    return c.JSON(fiber.Map{\n        \"status\": \"success\",\n        \"data\":   product.ToResponse(),\n    })\n}\n\n// Delete handles DELETE /api/v1/products/:id\nfunc (h *ProductHandler) Delete(c *fiber.Ctx) error {\n    id, err := strconv.ParseUint(c.Params(\"id\"), 10, 32)\n    if err != nil {\n        return domain.NewValidationError(\"Invalid product ID\", \"INVALID_ID\", err)\n    }\n\n    if err := h.service.Delete(c.Context(), uint(id)); err != nil {\n        return err\n    }\n\n    return c.JSON(fiber.Map{\n        \"status\":  \"success\",\n        \"message\": \"Product deleted successfully\",\n    })\n}\n</code></pre> <p>Points cles : - Utilise l'interface <code>ProductService</code>, pas l'implementation concrete - Validation avec <code>go-playground/validator</code> - Retourne des DTOs (<code>ToResponse()</code>) au lieu des entites directement - Gestion propre des erreurs avec <code>DomainError</code></p>"},{"location":"generated-project-guide/#etape-7-ajouter-les-routes","title":"Etape 7 : Ajouter les Routes","text":"<p>Modifier : <code>internal/adapters/http/routes.go</code></p> <p>Ajoutez le parametre <code>productHandler</code> et les routes :</p> <pre><code>func RegisterRoutes(\n    app *fiber.App,\n    authHandler *handlers.AuthHandler,\n    userHandler *handlers.UserHandler,\n    productHandler *handlers.ProductHandler,  // &lt;- AJOUTER\n    authMiddleware fiber.Handler,\n) {\n    // Health &amp; Swagger\n    RegisterHealthRoutes(app)\n    app.Get(\"/swagger/*\", swagger.WrapHandler)\n\n    // API v1\n    api := app.Group(\"/api\")\n    v1 := api.Group(\"/v1\")\n\n    // Auth routes (public)\n    auth := v1.Group(\"/auth\")\n    auth.Post(\"/register\", authHandler.Register)\n    auth.Post(\"/login\", authHandler.Login)\n    auth.Post(\"/refresh\", authHandler.Refresh)\n\n    // User routes (protected)\n    users := v1.Group(\"/users\", authMiddleware)\n    users.Get(\"/me\", userHandler.GetMe)\n    users.Get(\"\", userHandler.GetAllUsers)\n    users.Put(\"/:id\", userHandler.UpdateUser)\n    users.Delete(\"/:id\", userHandler.DeleteUser)\n\n    // ============================================\n    // AJOUTER : Product routes (protected)\n    // ============================================\n    products := v1.Group(\"/products\", authMiddleware)\n    products.Post(\"\", productHandler.Create)\n    products.Get(\"\", productHandler.List)\n    products.Get(\"/:id\", productHandler.GetByID)\n    products.Put(\"/:id\", productHandler.Update)\n    products.Delete(\"/:id\", productHandler.Delete)\n}\n</code></pre> <p>Avantages de cette approche: - Toutes les routes sont visibles en un seul fichier - Facile d'ajouter de nouveaux domaines - Le versioning de l'API est g\u00e9r\u00e9 de mani\u00e8re centralis\u00e9e</p>"},{"location":"generated-project-guide/#etape-8-ajouter-la-migration","title":"Etape 8 : Ajouter la Migration","text":"<p>Modifier : <code>internal/infrastructure/database/database.go</code></p> <pre><code>func NewDatabase(config *config.Config, logger zerolog.Logger) (*gorm.DB, error) {\n    // ... code existant ...\n\n    // AutoMigrate - AJOUTER models.Product\n    if err := db.AutoMigrate(\n        &amp;models.User{},\n        &amp;models.RefreshToken{},\n        &amp;models.Product{},  // &lt;- AJOUTER\n    ); err != nil {\n        return nil, fmt.Errorf(\"failed to auto-migrate: %w\", err)\n    }\n\n    // ... reste du code ...\n}\n</code></pre>"},{"location":"generated-project-guide/#etape-9-enregistrer-le-module-dans-le-bootstrap","title":"Etape 9 : Enregistrer le Module dans le Bootstrap","text":"<p>Modifier : <code>cmd/main.go</code></p> <pre><code>package main\n\nimport (\n    \"go.uber.org/fx\"\n\n    \"mon-projet/internal/domain/product\"  // &lt;- AJOUTER\n    \"mon-projet/internal/domain/user\"\n    \"mon-projet/internal/infrastructure/database\"\n    \"mon-projet/internal/infrastructure/server\"\n    \"mon-projet/pkg/auth\"\n    \"mon-projet/pkg/config\"\n    \"mon-projet/pkg/logger\"\n)\n\nfunc main() {\n    fx.New(\n        logger.Module,\n        config.Module,\n        database.Module,\n        auth.Module,\n        user.Module,\n        product.Module,  // &lt;- AJOUTER\n        server.Module,\n    ).Run()\n}\n</code></pre>"},{"location":"generated-project-guide/#verification-finale","title":"Verification finale","text":"<pre><code># 1. Verifier la compilation\ngo build ./...\n\n# 2. Lancer l'application\nmake run\n\n# 3. S'authentifier pour obtenir un token\nTOKEN=$(curl -s -X POST http://localhost:8080/api/v1/auth/login \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"email\":\"test@example.com\",\"password\":\"password123\"}' \\\n  | jq -r '.data.access_token')\n\n# 4. Creer un produit\ncurl -X POST http://localhost:8080/api/v1/products \\\n  -H \"Authorization: Bearer $TOKEN\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"name\": \"MacBook Pro 14\",\n    \"description\": \"Apple laptop with M3 chip\",\n    \"sku\": \"APPLE-MBP14-M3\",\n    \"price\": 1999.99,\n    \"stock\": 50\n  }'\n\n# 5. Lister les produits\ncurl -X GET \"http://localhost:8080/api/v1/products?page=1&amp;page_size=10\" \\\n  -H \"Authorization: Bearer $TOKEN\"\n\n# 6. Obtenir un produit par ID\ncurl -X GET http://localhost:8080/api/v1/products/1 \\\n  -H \"Authorization: Bearer $TOKEN\"\n\n# 7. Mettre a jour un produit\ncurl -X PUT http://localhost:8080/api/v1/products/1 \\\n  -H \"Authorization: Bearer $TOKEN\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"name\": \"MacBook Pro 14 - Updated\",\n    \"description\": \"Apple laptop with M3 Pro chip\",\n    \"price\": 2499.99,\n    \"stock\": 30,\n    \"active\": true\n  }'\n\n# 8. Supprimer un produit\ncurl -X DELETE http://localhost:8080/api/v1/products/1 \\\n  -H \"Authorization: Bearer $TOKEN\"\n</code></pre>"},{"location":"generated-project-guide/#resume-fichiers-creesmodifies","title":"Resume : Fichiers crees/modifies","text":"Action Fichier Description Creer <code>internal/models/product.go</code> Entite GORM + DTO Creer <code>internal/interfaces/product_repository.go</code> Interfaces (Ports) Creer <code>internal/adapters/repository/product_repository.go</code> Implementation GORM Creer <code>internal/domain/product/service.go</code> Business Logic Creer <code>internal/domain/product/module.go</code> fx.Module Creer <code>internal/adapters/handlers/product_handler.go</code> HTTP Handler Modifier <code>internal/infrastructure/server/server.go</code> Ajouter routes Modifier <code>internal/infrastructure/database/database.go</code> Ajouter AutoMigrate Modifier <code>cmd/main.go</code> Ajouter product.Module"},{"location":"generated-project-guide/#patterns-a-suivre","title":"Patterns \u00e0 suivre","text":""},{"location":"generated-project-guide/#1-error-handling","title":"1. Error Handling","text":"<p>Utiliser les DomainError:</p> <pre><code>// Dans service\nif user == nil {\n    return domain.NewNotFoundError(\"User not found\", \"USER_NOT_FOUND\", nil)\n}\n\nif exists {\n    return domain.NewConflictError(\"Email already exists\", \"EMAIL_EXISTS\", nil)\n}\n\n// Validation\nif err := validate.Struct(req); err != nil {\n    return domain.NewValidationError(\"Invalid input\", \"VALIDATION_ERROR\", err)\n}\n</code></pre> <p>Le middleware error_handler convertit automatiquement en r\u00e9ponses HTTP.</p>"},{"location":"generated-project-guide/#2-repository-pattern","title":"2. Repository Pattern","text":"<pre><code>// Interface (port)\ntype UserRepository interface {\n    Create(ctx context.Context, user *models.User) error\n    FindByEmail(ctx context.Context, email string) (*models.User, error)\n}\n\n// Impl\u00e9mentation (adapter)\ntype userRepositoryGORM struct {\n    db *gorm.DB\n}\n</code></pre>"},{"location":"generated-project-guide/#3-dependency-injection-avec-fx","title":"3. Dependency Injection avec fx","text":"<pre><code>// Provider\nfx.Provide(\n    fx.Annotate(\n        NewUserService,\n        fx.As(new(interfaces.UserService)),  // Interface\n    ),\n)\n\n// Consumer\ntype AuthHandler struct {\n    userService interfaces.UserService  // D\u00e9pend de l'interface\n}\n</code></pre>"},{"location":"generated-project-guide/#4-middleware-chain","title":"4. Middleware Chain","text":"<pre><code>protected := api.Group(\"/users\")\nprotected.Use(authMiddleware.Authenticate())  // JWT required\nprotected.Get(\"/\", userHandler.List)\n</code></pre>"},{"location":"generated-project-guide/#api-reference","title":"API Reference","text":""},{"location":"generated-project-guide/#endpoints-disponibles","title":"Endpoints disponibles","text":""},{"location":"generated-project-guide/#health-check","title":"Health Check","text":"<pre><code>GET /health\n</code></pre> <p>Response (200): <pre><code>{\n  \"status\": \"ok\"\n}\n</code></pre></p>"},{"location":"generated-project-guide/#authentication","title":"Authentication","text":""},{"location":"generated-project-guide/#register","title":"Register","text":"<pre><code>POST /api/v1/auth/register\nContent-Type: application/json\n</code></pre> <p>Body: <pre><code>{\n  \"email\": \"user@example.com\",\n  \"password\": \"securePassword123\"\n}\n</code></pre></p> <p>Validation: - email: required, valid email, max 255 chars - password: required, min 8 chars, max 72 chars</p> <p>Response (201): <pre><code>{\n  \"status\": \"success\",\n  \"data\": {\n    \"access_token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\",\n    \"refresh_token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\",\n    \"token_type\": \"Bearer\",\n    \"expires_in\": 900\n  }\n}\n</code></pre></p> <p>Errors: - <code>400 Bad Request</code>: Invalid input - <code>409 Conflict</code>: Email already exists</p> <p>Exemple curl: <pre><code>curl -X POST http://localhost:8080/api/v1/auth/register \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"email\":\"user@example.com\",\"password\":\"password123\"}'\n</code></pre></p>"},{"location":"generated-project-guide/#login","title":"Login","text":"<pre><code>POST /api/v1/auth/login\nContent-Type: application/json\n</code></pre> <p>Body: <pre><code>{\n  \"email\": \"user@example.com\",\n  \"password\": \"securePassword123\"\n}\n</code></pre></p> <p>Response (200): <pre><code>{\n  \"status\": \"success\",\n  \"data\": {\n    \"access_token\": \"eyJhbGc...\",\n    \"refresh_token\": \"eyJhbGc...\",\n    \"token_type\": \"Bearer\",\n    \"expires_in\": 900\n  }\n}\n</code></pre></p> <p>Errors: - <code>400 Bad Request</code>: Invalid input - <code>401 Unauthorized</code>: Invalid credentials</p> <p>Exemple curl: <pre><code>curl -X POST http://localhost:8080/api/v1/auth/login \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"email\":\"user@example.com\",\"password\":\"password123\"}'\n</code></pre></p>"},{"location":"generated-project-guide/#refresh-token","title":"Refresh Token","text":"<pre><code>POST /api/v1/auth/refresh\nContent-Type: application/json\n</code></pre> <p>Body: <pre><code>{\n  \"refresh_token\": \"eyJhbGc...\"\n}\n</code></pre></p> <p>Response (200): <pre><code>{\n  \"status\": \"success\",\n  \"data\": {\n    \"access_token\": \"eyJhbGc...\",\n    \"token_type\": \"Bearer\",\n    \"expires_in\": 900\n  }\n}\n</code></pre></p> <p>Errors: - <code>400 Bad Request</code>: Invalid input - <code>401 Unauthorized</code>: Invalid or expired refresh token</p> <p>Exemple curl: <pre><code>REFRESH_TOKEN=\"&lt;refresh_token_from_login&gt;\"\ncurl -X POST http://localhost:8080/api/v1/auth/refresh \\\n  -H \"Content-Type: application/json\" \\\n  -d \"{\\\"refresh_token\\\":\\\"$REFRESH_TOKEN\\\"}\"\n</code></pre></p>"},{"location":"generated-project-guide/#users-protected","title":"Users (Protected)","text":"<p>Tous les endpoints users requi\u00e8rent un JWT token valide.</p>"},{"location":"generated-project-guide/#list-users","title":"List Users","text":"<pre><code>GET /api/v1/users\nAuthorization: Bearer &lt;access_token&gt;\n</code></pre> <p>Response (200): <pre><code>{\n  \"status\": \"success\",\n  \"data\": [\n    {\n      \"id\": 1,\n      \"email\": \"user1@example.com\",\n      \"created_at\": \"2026-01-09T10:00:00Z\",\n      \"updated_at\": \"2026-01-09T10:00:00Z\"\n    },\n    {\n      \"id\": 2,\n      \"email\": \"user2@example.com\",\n      \"created_at\": \"2026-01-09T11:00:00Z\",\n      \"updated_at\": \"2026-01-09T11:00:00Z\"\n    }\n  ]\n}\n</code></pre></p> <p>Errors: - <code>401 Unauthorized</code>: Missing or invalid token</p> <p>Exemple curl: <pre><code>TOKEN=\"&lt;access_token&gt;\"\ncurl -X GET http://localhost:8080/api/v1/users \\\n  -H \"Authorization: Bearer $TOKEN\"\n</code></pre></p>"},{"location":"generated-project-guide/#get-user-by-id","title":"Get User by ID","text":"<pre><code>GET /api/v1/users/:id\nAuthorization: Bearer &lt;access_token&gt;\n</code></pre> <p>Response (200): <pre><code>{\n  \"status\": \"success\",\n  \"data\": {\n    \"id\": 1,\n    \"email\": \"user@example.com\",\n    \"created_at\": \"2026-01-09T10:00:00Z\",\n    \"updated_at\": \"2026-01-09T10:00:00Z\"\n  }\n}\n</code></pre></p> <p>Errors: - <code>401 Unauthorized</code>: Invalid token - <code>404 Not Found</code>: User not found</p> <p>Exemple curl: <pre><code>TOKEN=\"&lt;access_token&gt;\"\ncurl -X GET http://localhost:8080/api/v1/users/1 \\\n  -H \"Authorization: Bearer $TOKEN\"\n</code></pre></p>"},{"location":"generated-project-guide/#update-user","title":"Update User","text":"<pre><code>PUT /api/v1/users/:id\nAuthorization: Bearer &lt;access_token&gt;\nContent-Type: application/json\n</code></pre> <p>Body: <pre><code>{\n  \"email\": \"newemail@example.com\"\n}\n</code></pre></p> <p>Response (200): <pre><code>{\n  \"status\": \"success\",\n  \"data\": {\n    \"id\": 1,\n    \"email\": \"newemail@example.com\",\n    \"created_at\": \"2026-01-09T10:00:00Z\",\n    \"updated_at\": \"2026-01-10T15:30:00Z\"\n  }\n}\n</code></pre></p> <p>Errors: - <code>400 Bad Request</code>: Invalid input - <code>401 Unauthorized</code>: Invalid token - <code>404 Not Found</code>: User not found - <code>409 Conflict</code>: Email already exists</p>"},{"location":"generated-project-guide/#delete-user","title":"Delete User","text":"<pre><code>DELETE /api/v1/users/:id\nAuthorization: Bearer &lt;access_token&gt;\n</code></pre> <p>Response (200): <pre><code>{\n  \"status\": \"success\",\n  \"message\": \"User deleted successfully\"\n}\n</code></pre></p> <p>Errors: - <code>401 Unauthorized</code>: Invalid token - <code>404 Not Found</code>: User not found</p> <p>Note: Utilise soft delete (DeletedAt), les donn\u00e9es restent en DB.</p>"},{"location":"generated-project-guide/#workflow-complet-avec-lapi","title":"Workflow complet avec l'API","text":"<pre><code># 1. Register\nREGISTER_RESP=$(curl -s -X POST http://localhost:8080/api/v1/auth/register \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"email\":\"test@example.com\",\"password\":\"password123\"}')\n\n# Extraire access_token\nACCESS_TOKEN=$(echo $REGISTER_RESP | jq -r '.data.access_token')\nREFRESH_TOKEN=$(echo $REGISTER_RESP | jq -r '.data.refresh_token')\n\n# 2. List users (avec token)\ncurl -X GET http://localhost:8080/api/v1/users \\\n  -H \"Authorization: Bearer $ACCESS_TOKEN\"\n\n# 3. Update user\ncurl -X PUT http://localhost:8080/api/v1/users/1 \\\n  -H \"Authorization: Bearer $ACCESS_TOKEN\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"email\":\"updated@example.com\"}'\n\n# 4. Quand access token expire (15min), utiliser refresh token\nNEW_ACCESS=$(curl -s -X POST http://localhost:8080/api/v1/auth/refresh \\\n  -H \"Content-Type: application/json\" \\\n  -d \"{\\\"refresh_token\\\":\\\"$REFRESH_TOKEN\\\"}\" | jq -r '.data.access_token')\n\n# 5. Continuer avec nouveau token\ncurl -X GET http://localhost:8080/api/v1/users \\\n  -H \"Authorization: Bearer $NEW_ACCESS\"\n</code></pre>"},{"location":"generated-project-guide/#tests","title":"Tests","text":""},{"location":"generated-project-guide/#organisation-des-tests","title":"Organisation des tests","text":"<p>Les tests sont co-localis\u00e9s avec le code source:</p> <pre><code>internal/\n\u251c\u2500\u2500 adapters/\n\u2502   \u251c\u2500\u2500 handlers/\n\u2502   \u2502   \u251c\u2500\u2500 auth_handler.go\n\u2502   \u2502   \u251c\u2500\u2500 auth_handler_test.go\n\u2502   \u2502   \u251c\u2500\u2500 user_handler.go\n\u2502   \u2502   \u2514\u2500\u2500 user_handler_test.go\n\u2502   \u251c\u2500\u2500 middleware/\n\u2502   \u2502   \u251c\u2500\u2500 auth_middleware.go\n\u2502   \u2502   \u2514\u2500\u2500 auth_middleware_test.go\n\u2502   \u2514\u2500\u2500 repository/\n\u2502       \u251c\u2500\u2500 user_repository.go\n\u2502       \u2514\u2500\u2500 user_repository_test.go\n\u251c\u2500\u2500 domain/\n\u2502   \u251c\u2500\u2500 user/\n\u2502   \u2502   \u251c\u2500\u2500 service.go\n\u2502   \u2502   \u2514\u2500\u2500 service_test.go\n\u2502   \u251c\u2500\u2500 errors.go\n\u2502   \u2514\u2500\u2500 errors_test.go\n</code></pre>"},{"location":"generated-project-guide/#executer-les-tests","title":"Ex\u00e9cuter les tests","text":"<pre><code># Tous les tests\nmake test\n\n# Tests avec coverage\nmake test-coverage\n\n# Ouvrir le rapport HTML\nopen coverage.html  # macOS\nxdg-open coverage.html  # Linux\n\n# Tests d'un package sp\u00e9cifique\ngo test -v ./internal/domain/user\n\n# Test sp\u00e9cifique\ngo test -run TestRegister ./internal/adapters/handlers\n\n# Tests avec race detector (d\u00e9tection de race conditions)\ngo test -race ./...\n</code></pre>"},{"location":"generated-project-guide/#types-de-tests","title":"Types de tests","text":""},{"location":"generated-project-guide/#1-tests-unitaires","title":"1. Tests unitaires","text":"<p>Testent une fonction ou m\u00e9thode isol\u00e9e, avec mocks.</p> <p>Exemple: Test du service</p> <pre><code>// internal/domain/user/service_test.go\npackage user\n\nimport (\n    \"context\"\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n    \"github.com/stretchr/testify/mock\"\n)\n\ntype MockUserRepository struct {\n    mock.Mock\n}\n\nfunc (m *MockUserRepository) Create(ctx context.Context, user *User) error {\n    args := m.Called(ctx, user)\n    return args.Error(0)\n}\n\nfunc TestService_Register(t *testing.T) {\n    // Arrange\n    mockRepo := new(MockUserRepository)\n    logger := zerolog.Nop()\n    service := NewService(mockRepo, logger)\n\n    mockRepo.On(\"Create\", mock.Anything, mock.AnythingOfType(\"*user.User\")).Return(nil)\n\n    // Act\n    user, err := service.Register(context.Background(), \"test@example.com\", \"password123\")\n\n    // Assert\n    assert.NoError(t, err)\n    assert.NotNil(t, user)\n    assert.Equal(t, \"test@example.com\", user.Email)\n    mockRepo.AssertExpectations(t)\n}\n</code></pre>"},{"location":"generated-project-guide/#2-tests-dintegration","title":"2. Tests d'int\u00e9gration","text":"<p>Testent plusieurs composants ensemble, avec DB r\u00e9elle (SQLite in-memory).</p> <p>Exemple: Test handler avec DB</p> <pre><code>// internal/adapters/handlers/auth_handler_integration_test.go\nfunc TestAuthHandler_RegisterIntegration(t *testing.T) {\n    // Setup DB in-memory\n    db, err := gorm.Open(sqlite.Open(\"file::memory:?cache=shared\"), &amp;gorm.Config{})\n    require.NoError(t, err)\n\n    db.AutoMigrate(&amp;models.User{})\n\n    // Create real dependencies\n    repo := repository.NewUserRepository(db)\n    service := user.NewService(repo, zerolog.Nop())\n    handler := handlers.NewAuthHandler(service, \"test-secret\")\n\n    // Create Fiber app\n    app := fiber.New()\n    app.Post(\"/register\", handler.Register)\n\n    // Test request\n    body := `{\"email\":\"test@example.com\",\"password\":\"password123\"}`\n    req := httptest.NewRequest(\"POST\", \"/register\", strings.NewReader(body))\n    req.Header.Set(\"Content-Type\", \"application/json\")\n\n    resp, err := app.Test(req)\n    require.NoError(t, err)\n\n    // Assert\n    assert.Equal(t, fiber.StatusCreated, resp.StatusCode)\n\n    var result map[string]interface{}\n    json.NewDecoder(resp.Body).Decode(&amp;result)\n    assert.Equal(t, \"success\", result[\"status\"])\n}\n</code></pre>"},{"location":"generated-project-guide/#3-tests-table-driven","title":"3. Tests table-driven","text":"<p>Pour tester plusieurs cas avec une structure commune:</p> <pre><code>func TestValidateEmail(t *testing.T) {\n    tests := []struct {\n        name    string\n        email   string\n        wantErr bool\n    }{\n        {\"valid email\", \"user@example.com\", false},\n        {\"invalid email - no @\", \"userexample.com\", true},\n        {\"invalid email - no domain\", \"user@\", true},\n        {\"empty email\", \"\", true},\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            err := validateEmail(tt.email)\n            if tt.wantErr {\n                assert.Error(t, err)\n            } else {\n                assert.NoError(t, err)\n            }\n        })\n    }\n}\n</code></pre>"},{"location":"generated-project-guide/#best-practices-pour-les-tests","title":"Best practices pour les tests","text":"<ol> <li> <p>Utilisez testify/assert pour assertions claires:    <pre><code>assert.Equal(t, expected, actual)\nassert.NoError(t, err)\nassert.NotNil(t, user)\n</code></pre></p> </li> <li> <p>Arrange-Act-Assert pattern:    <pre><code>// Arrange - Setup\nmockRepo := new(MockUserRepository)\n\n// Act - Execute\nresult, err := service.DoSomething()\n\n// Assert - Verify\nassert.NoError(t, err)\nassert.Equal(t, expected, result)\n</code></pre></p> </li> <li> <p>Mock les d\u00e9pendances externes:</p> </li> <li>DB (sauf pour tests d'int\u00e9gration)</li> <li>APIs externes</li> <li> <p>Services tiers</p> </li> <li> <p>Tests d'int\u00e9gration avec SQLite in-memory:    <pre><code>db, _ := gorm.Open(sqlite.Open(\":memory:\"), &amp;gorm.Config{})\n</code></pre></p> </li> <li> <p>Clean up apr\u00e8s chaque test:    <pre><code>t.Cleanup(func() {\n    db.Exec(\"DELETE FROM users\")\n})\n</code></pre></p> </li> <li> <p>Noms de tests descriptifs:    <pre><code>func TestUserService_Register_WhenEmailAlreadyExists_ReturnsConflictError(t *testing.T)\n</code></pre></p> </li> </ol>"},{"location":"generated-project-guide/#coverage","title":"Coverage","text":"<p>Objectif: &gt; 80% coverage</p> <pre><code># G\u00e9n\u00e9rer rapport\nmake test-coverage\n\n# Voir coverage par package\ngo test -cover ./...\n\n# Output:\n# ok      mon-projet/internal/domain/user         0.123s  coverage: 85.7% of statements\n# ok      mon-projet/internal/adapters/handlers   0.234s  coverage: 92.3% of statements\n</code></pre>"},{"location":"generated-project-guide/#base-de-donnees","title":"Base de donn\u00e9es","text":""},{"location":"generated-project-guide/#migrations","title":"Migrations","text":"<p>Le projet utilise GORM AutoMigrate pour simplifier les migrations en d\u00e9veloppement:</p> <pre><code>// internal/infrastructure/database/database.go\ndb.AutoMigrate(\n    &amp;models.User{},\n    &amp;models.RefreshToken{},\n)\n</code></pre> <p>AutoMigrate: - Cr\u00e9e les tables si elles n'existent pas - Ajoute les colonnes manquantes - Cr\u00e9e les indexes - NE supprime PAS de colonnes ou tables</p> <p>Pour la production, consid\u00e9rer une solution de migrations versionn\u00e9es:</p> <ul> <li>golang-migrate/migrate: Migrations SQL ou Go</li> <li>pressly/goose: Migrations up/down</li> <li>GORM Migrator avanc\u00e9: API programmatique</li> </ul> <p>Exemple avec golang-migrate:</p> <pre><code># Installer migrate\ngo install -tags 'postgres' github.com/golang-migrate/migrate/v4/cmd/migrate@latest\n\n# Cr\u00e9er migration\nmigrate create -ext sql -dir migrations -seq create_users_table\n\n# Fichiers cr\u00e9\u00e9s:\n# migrations/000001_create_users_table.up.sql\n# migrations/000001_create_users_table.down.sql\n\n# Run migrations\nmigrate -path migrations -database \"postgresql://user:pass@localhost/dbname?sslmode=disable\" up\n</code></pre>"},{"location":"generated-project-guide/#modeles-gorm","title":"Mod\u00e8les GORM","text":"<p>Conventions et patterns:</p> <pre><code>type User struct {\n    ID        uint           `gorm:\"primarykey\" json:\"id\"`\n    CreatedAt time.Time      `json:\"created_at\"`\n    UpdatedAt time.Time      `json:\"updated_at\"`\n    DeletedAt gorm.DeletedAt `gorm:\"index\" json:\"-\"`\n\n    Email    string `gorm:\"uniqueIndex;not null\" json:\"email\" validate:\"required,email\"`\n    Password string `gorm:\"not null\" json:\"-\"`\n}\n</code></pre> <p>Tags GORM importants:</p> Tag Description <code>primarykey</code> Cl\u00e9 primaire <code>uniqueIndex</code> Index unique <code>index</code> Index simple <code>not null</code> Colonne NOT NULL <code>default:value</code> Valeur par d\u00e9faut <code>size:255</code> Taille de colonne <code>type:varchar(100)</code> Type SQL custom <code>foreignKey:UserID</code> Cl\u00e9 \u00e9trang\u00e8re <code>references:ID</code> R\u00e9f\u00e9rence FK <p>Conventions:</p> <ul> <li>Soft deletes: <code>DeletedAt gorm.DeletedAt</code></li> <li>Timestamps auto: <code>CreatedAt</code>, <code>UpdatedAt</code></li> <li>JSON hiding: <code>json:\"-\"</code> pour password</li> <li>Index sur FK: Toujours indexer les cl\u00e9s \u00e9trang\u00e8res</li> </ul>"},{"location":"generated-project-guide/#queries-avancees","title":"Queries avanc\u00e9es","text":""},{"location":"generated-project-guide/#pagination","title":"Pagination","text":"<pre><code>var users []models.User\nlimit := 10\noffset := 20\n\ndb.Limit(limit).Offset(offset).Find(&amp;users)\n</code></pre>"},{"location":"generated-project-guide/#filtering","title":"Filtering","text":"<pre><code>// Where simple\ndb.Where(\"email = ?\", \"user@example.com\").First(&amp;user)\n\n// Where avec multiple conditions\ndb.Where(\"created_at &gt; ? AND email LIKE ?\", time.Now().Add(-24*time.Hour), \"%@example.com\").Find(&amp;users)\n\n// Or\ndb.Where(\"email = ?\", email1).Or(\"email = ?\", email2).Find(&amp;users)\n</code></pre>"},{"location":"generated-project-guide/#sorting","title":"Sorting","text":"<pre><code>// Order ASC\ndb.Order(\"created_at asc\").Find(&amp;users)\n\n// Order DESC\ndb.Order(\"created_at desc\").Find(&amp;users)\n\n// Multiple sorts\ndb.Order(\"created_at desc, email asc\").Find(&amp;users)\n</code></pre>"},{"location":"generated-project-guide/#joins","title":"Joins","text":"<pre><code>// Inner join\ndb.Joins(\"LEFT JOIN refresh_tokens ON refresh_tokens.user_id = users.id\").\n   Where(\"refresh_tokens.expires_at &gt; ?\", time.Now()).\n   Find(&amp;users)\n\n// Preload associations\ndb.Preload(\"RefreshTokens\").Find(&amp;users)\n</code></pre>"},{"location":"generated-project-guide/#aggregations","title":"Aggregations","text":"<pre><code>// Count\nvar count int64\ndb.Model(&amp;models.User{}).Count(&amp;count)\n\n// With where\ndb.Model(&amp;models.User{}).Where(\"created_at &gt; ?\", yesterday).Count(&amp;count)\n</code></pre>"},{"location":"generated-project-guide/#transactions","title":"Transactions","text":"<pre><code>err := db.Transaction(func(tx *gorm.DB) error {\n    // Create user\n    if err := tx.Create(&amp;user).Error; err != nil {\n        return err  // Rollback\n    }\n\n    // Create profile\n    if err := tx.Create(&amp;profile).Error; err != nil {\n        return err  // Rollback\n    }\n\n    return nil  // Commit\n})\n</code></pre>"},{"location":"generated-project-guide/#raw-sql","title":"Raw SQL","text":"<pre><code>// Raw query\nvar users []models.User\ndb.Raw(\"SELECT * FROM users WHERE email LIKE ?\", \"%@example.com\").Scan(&amp;users)\n\n// Exec\ndb.Exec(\"UPDATE users SET email = ? WHERE id = ?\", newEmail, userID)\n</code></pre>"},{"location":"generated-project-guide/#performance-tips","title":"Performance tips","text":"<ol> <li> <p>Index les colonnes fr\u00e9quemment requ\u00eat\u00e9es:    <pre><code>Email string `gorm:\"uniqueIndex\"`\n</code></pre></p> </li> <li> <p>\u00c9viter N+1 queries avec Preload:    <pre><code>// \u274c N+1\nfor _, user := range users {\n    db.Model(&amp;user).Association(\"RefreshTokens\").Find(&amp;tokens)\n}\n\n// \u2705 Single query\ndb.Preload(\"RefreshTokens\").Find(&amp;users)\n</code></pre></p> </li> <li> <p>Select seulement les colonnes n\u00e9cessaires:    <pre><code>db.Select(\"id, email\").Find(&amp;users)\n</code></pre></p> </li> <li> <p>Utiliser les connections pools:    <pre><code>sqlDB, _ := db.DB()\nsqlDB.SetMaxIdleConns(10)\nsqlDB.SetMaxOpenConns(100)\nsqlDB.SetConnMaxLifetime(time.Hour)\n</code></pre></p> </li> </ol>"},{"location":"generated-project-guide/#securite","title":"S\u00e9curit\u00e9","text":""},{"location":"generated-project-guide/#authentification-jwt","title":"Authentification JWT","text":""},{"location":"generated-project-guide/#flow-complet","title":"Flow complet","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Client  \u2502                                  \u2502 Server  \u2502\n\u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518                                  \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518\n     \u2502                                            \u2502\n     \u2502 1. POST /auth/register or /login          \u2502\n     \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502\n     \u2502                                            \u2502\n     \u2502 2. Access Token (15min) + Refresh (7d)    \u2502\n     \u2502&lt;\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\n     \u2502                                            \u2502\n     \u2502 3. GET /users (Authorization: Bearer AT)  \u2502\n     \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502\n     \u2502                                            \u2502\n     \u2502 4. Response                                \u2502\n     \u2502&lt;\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\n     \u2502                                            \u2502\n     \u2502 [15 minutes later - Access Token expires] \u2502\n     \u2502                                            \u2502\n     \u2502 5. GET /users (Authorization: Bearer AT)  \u2502\n     \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502\n     \u2502                                            \u2502\n     \u2502 6. 401 Unauthorized (token expired)        \u2502\n     \u2502&lt;\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\n     \u2502                                            \u2502\n     \u2502 7. POST /auth/refresh (Refresh Token)     \u2502\n     \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502\n     \u2502                                            \u2502\n     \u2502 8. New Access Token (15min)                \u2502\n     \u2502&lt;\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\n     \u2502                                            \u2502\n     \u2502 9. Continue with new Access Token          \u2502\n     \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502\n     \u2502                                            \u2502\n</code></pre>"},{"location":"generated-project-guide/#stockage-des-tokens-cote-client","title":"Stockage des tokens (c\u00f4t\u00e9 client)","text":"<p>Access Token (courte dur\u00e9e: 15min): - Recommand\u00e9: En m\u00e9moire (variable JavaScript) - Pas de localStorage (vuln\u00e9rable \u00e0 XSS) - Perdu au refresh de page \u2192 Utiliser refresh token</p> <p>Refresh Token (longue dur\u00e9e: 7j): - Option 1: httpOnly cookie (le plus s\u00e9curis\u00e9) - Option 2: localStorage (si pas de XSS risk)</p> <p>Exemple React:</p> <pre><code>// Store access token in memory\nlet accessToken = null;\n\n// Login\nconst login = async (email, password) =&gt; {\n    const response = await fetch('/api/v1/auth/login', {\n        method: 'POST',\n        headers: {'Content-Type': 'application/json'},\n        body: JSON.stringify({email, password})\n    });\n    const data = await response.json();\n\n    accessToken = data.data.access_token;  // Memory\n    localStorage.setItem('refresh_token', data.data.refresh_token);\n};\n\n// API call\nconst fetchUsers = async () =&gt; {\n    const response = await fetch('/api/v1/users', {\n        headers: {'Authorization': `Bearer ${accessToken}`}\n    });\n\n    if (response.status === 401) {\n        // Token expired, refresh\n        await refreshAccessToken();\n        // Retry request\n    }\n};\n\n// Refresh\nconst refreshAccessToken = async () =&gt; {\n    const refreshToken = localStorage.getItem('refresh_token');\n    const response = await fetch('/api/v1/auth/refresh', {\n        method: 'POST',\n        headers: {'Content-Type': 'application/json'},\n        body: JSON.stringify({refresh_token: refreshToken})\n    });\n    const data = await response.json();\n    accessToken = data.data.access_token;\n};\n</code></pre>"},{"location":"generated-project-guide/#protection-des-routes","title":"Protection des routes","text":"<p>Middleware d'authentification:</p> <pre><code>// internal/adapters/middleware/auth_middleware.go\nfunc (m *AuthMiddleware) Authenticate() fiber.Handler {\n    return func(c *fiber.Ctx) error {\n        // 1. Extract token\n        authHeader := c.Get(\"Authorization\")\n        if authHeader == \"\" {\n            return fiber.NewError(fiber.StatusUnauthorized, \"Missing authorization header\")\n        }\n\n        // 2. Parse \"Bearer &lt;token&gt;\"\n        parts := strings.Split(authHeader, \" \")\n        if len(parts) != 2 || parts[0] != \"Bearer\" {\n            return fiber.NewError(fiber.StatusUnauthorized, \"Invalid authorization format\")\n        }\n\n        // 3. Validate JWT\n        claims, err := auth.ParseToken(parts[1], m.jwtSecret)\n        if err != nil {\n            return fiber.NewError(fiber.StatusUnauthorized, \"Invalid token\")\n        }\n\n        // 4. Inject user ID in context\n        c.Locals(\"user_id\", claims.UserID)\n\n        return c.Next()\n    }\n}\n</code></pre> <p>Utilisation:</p> <pre><code>// Protected routes\nusers := api.Group(\"/users\")\nusers.Use(authMiddleware.Authenticate())  // Middleware appliqu\u00e9\nusers.Get(\"/\", userHandler.List)\n</code></pre> <p>Dans le handler, r\u00e9cup\u00e9rer user ID:</p> <pre><code>func (h *UserHandler) List(c *fiber.Ctx) error {\n    userID := c.Locals(\"user_id\").(uint)\n    // Utiliser userID pour v\u00e9rifier permissions, etc.\n}\n</code></pre>"},{"location":"generated-project-guide/#validation-des-entrees","title":"Validation des entr\u00e9es","text":"<p>go-playground/validator v10:</p> <pre><code>type RegisterRequest struct {\n    Email    string `json:\"email\" validate:\"required,email,max=255\"`\n    Password string `json:\"password\" validate:\"required,min=8,max=72\"`\n}\n\n// Dans handler\nvalidate := validator.New()\nif err := validate.Struct(req); err != nil {\n    return domain.NewValidationError(\"Invalid input\", \"VALIDATION_ERROR\", err)\n}\n</code></pre> <p>Tags de validation courants:</p> Tag Description <code>required</code> Champ obligatoire <code>email</code> Format email valide <code>min=N</code> Longueur/valeur minimum <code>max=N</code> Longueur/valeur maximum <code>len=N</code> Longueur exacte <code>gte=N</code> Greater than or equal <code>lte=N</code> Less than or equal <code>alpha</code> Lettres seulement <code>alphanum</code> Lettres + chiffres <code>numeric</code> Chiffres seulement <code>uuid</code> Format UUID <code>url</code> Format URL <p>Custom validators:</p> <pre><code>validate := validator.New()\n\n// Register custom validator\nvalidate.RegisterValidation(\"strong_password\", func(fl validator.FieldLevel) bool {\n    password := fl.Field().String()\n    // Custom logic: must contain uppercase, lowercase, number, special char\n    return hasUppercase(password) &amp;&amp; hasLowercase(password) &amp;&amp; hasNumber(password)\n})\n\n// Usage\ntype Request struct {\n    Password string `validate:\"required,strong_password\"`\n}\n</code></pre>"},{"location":"generated-project-guide/#hashage-des-mots-de-passe","title":"Hashage des mots de passe","text":"<p>bcrypt (golang.org/x/crypto/bcrypt):</p> <pre><code>// internal/domain/user/service.go\n\nimport \"golang.org/x/crypto/bcrypt\"\n\nfunc (s *Service) Register(ctx context.Context, email, password string) (*models.User, error) {\n    // Hash the password\n    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)\n    if err != nil {\n        return nil, err\n    }\n\n    // Create user with hashed password\n    user := &amp;models.User{\n        Email:        email,\n        PasswordHash: string(hashedPassword),\n    }\n\n    if err := s.repo.CreateUser(ctx, user); err != nil {\n        return nil, err\n    }\n\n    return user, nil\n}\n\nfunc (s *Service) Login(ctx context.Context, email, password string) (*models.User, error) {\n    user, err := s.repo.GetUserByEmail(ctx, email)\n    if err != nil {\n        return nil, err\n    }\n\n    // Compare password\n    if err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(password)); err != nil {\n        return nil, domain.NewUnauthorizedError(\"Invalid credentials\", \"INVALID_CREDENTIALS\", err)\n    }\n\n    return user, nil\n}\n</code></pre> <p>DefaultCost = 10 (2^10 iterations) - Bon \u00e9quilibre s\u00e9curit\u00e9/performance</p> <p>Note: Le hashage de mot de passe est g\u00e9r\u00e9 dans le service (business logic), pas dans l'entit\u00e9. L'entit\u00e9 <code>models.User</code> stocke le <code>PasswordHash</code> qui est toujours hach\u00e9.</p> <p>Utilisation:</p> <pre><code>// Register (dans le service)\nuser, err := userService.Register(ctx, email, plainPassword)\nif err != nil {\n    return err\n}\ndb.Create(user)\n\n// Login\nuser, _ := repo.FindByEmail(email)\nif err := user.ComparePassword(plainPassword); err != nil {\n    return domain.NewUnauthorizedError(\"Invalid credentials\", \"INVALID_CREDENTIALS\", err)\n}\n</code></pre>"},{"location":"generated-project-guide/#checklist-securite","title":"Checklist s\u00e9curit\u00e9","text":"<p>Production checklist:</p> <ul> <li> JWT_SECRET fort: G\u00e9n\u00e9r\u00e9 avec <code>openssl rand -base64 32</code></li> <li> HTTPS en production: Toujours utiliser TLS</li> <li> Rate limiting: Impl\u00e9menter avec fiber/limiter   <pre><code>import \"github.com/gofiber/fiber/v2/middleware/limiter\"\n\napp.Use(limiter.New(limiter.Config{\n    Max:        100,\n    Expiration: 1 * time.Minute,\n}))\n</code></pre></li> <li> CORS configur\u00e9: Restreindre les origins   <pre><code>import \"github.com/gofiber/fiber/v2/middleware/cors\"\n\napp.Use(cors.New(cors.Config{\n    AllowOrigins: \"https://your-frontend.com\",\n    AllowHeaders: \"Origin, Content-Type, Accept, Authorization\",\n}))\n</code></pre></li> <li> Validation stricte: Tous les inputs valid\u00e9s</li> <li> SQL Injection: GORM le pr\u00e9vient automatiquement</li> <li> XSS: \u00c9chapper les outputs HTML (si templates)</li> <li> Logs sans secrets: Jamais logger passwords, tokens   <pre><code>// \u274c BAD\nlogger.Info().Str(\"password\", password).Msg(\"User login\")\n\n// \u2705 GOOD\nlogger.Info().Str(\"email\", email).Msg(\"User login\")\n</code></pre></li> <li> Environment variables: Secrets dans .env (pas dans code)</li> <li> DB SSL: <code>DB_SSLMODE=require</code> en production</li> <li> Helmet headers: Impl\u00e9menter security headers   <pre><code>import \"github.com/gofiber/fiber/v2/middleware/helmet\"\n\napp.Use(helmet.New())\n</code></pre></li> <li> Timeout requests: \u00c9viter DoS   <pre><code>app := fiber.New(fiber.Config{\n    ReadTimeout:  10 * time.Second,\n    WriteTimeout: 10 * time.Second,\n    IdleTimeout:  30 * time.Second,\n})\n</code></pre></li> </ul>"},{"location":"generated-project-guide/#deploiement","title":"D\u00e9ploiement","text":""},{"location":"generated-project-guide/#docker","title":"Docker","text":""},{"location":"generated-project-guide/#build-de-limage","title":"Build de l'image","text":"<pre><code>make docker-build\n</code></pre> <p>Ou manuellement:</p> <pre><code>docker build -t mon-projet:latest .\n</code></pre> <p>Le Dockerfile g\u00e9n\u00e9r\u00e9 utilise un build multi-stage:</p> <pre><code># Stage 1: Build\nFROM golang:1.25-alpine AS builder\n\nWORKDIR /app\nCOPY go.mod go.sum ./\nRUN go mod tidy\n\nCOPY . .\nRUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main cmd/main.go\n\n# Stage 2: Runtime\nFROM alpine:latest\n\nRUN apk --no-cache add ca-certificates\nWORKDIR /root/\n\nCOPY --from=builder /app/main .\nCOPY .env.example .env\n\nEXPOSE 8080\nCMD [\"./main\"]\n</code></pre> <p>Avantages: - Image finale l\u00e9g\u00e8re (~15-20MB vs ~1GB) - S\u00e9curit\u00e9 (image alpine minimale) - Binaire statique (pas de d\u00e9pendances)</p>"},{"location":"generated-project-guide/#run-avec-docker","title":"Run avec Docker","text":"<pre><code>docker run -p 8080:8080 \\\n  -e DB_HOST=host.docker.internal \\\n  -e DB_PASSWORD=postgres \\\n  -e JWT_SECRET=&lt;votre_secret&gt; \\\n  mon-projet:latest\n</code></pre> <p>Note: <code>host.docker.internal</code> permet d'acc\u00e9der \u00e0 localhost depuis Docker.</p>"},{"location":"generated-project-guide/#docker-compose","title":"Docker Compose","text":"<p>Si <code>docker-compose.yml</code> est g\u00e9n\u00e9r\u00e9:</p> <pre><code>version: '3.8'\n\nservices:\n  app:\n    build: .\n    ports:\n      - \"8080:8080\"\n    environment:\n      DB_HOST: postgres\n      DB_USER: postgres\n      DB_PASSWORD: postgres\n      DB_NAME: mon-projet\n      JWT_SECRET: ${JWT_SECRET}\n    depends_on:\n      - postgres\n\n  postgres:\n    image: postgres:16-alpine\n    environment:\n      POSTGRES_DB: mon-projet\n      POSTGRES_USER: postgres\n      POSTGRES_PASSWORD: postgres\n    ports:\n      - \"5432:5432\"\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n\nvolumes:\n  postgres_data:\n</code></pre> <p>Lancer:</p> <pre><code># Set JWT_SECRET\nexport JWT_SECRET=$(openssl rand -base64 32)\n\n# Start all services\ndocker-compose up -d\n\n# View logs\ndocker-compose logs -f app\n\n# Stop\ndocker-compose down\n</code></pre>"},{"location":"generated-project-guide/#kubernetes","title":"Kubernetes","text":"<p>Manifests basiques pour d\u00e9ploiement K8s:</p>"},{"location":"generated-project-guide/#secret","title":"Secret","text":"<pre><code># k8s/secret.yaml\napiVersion: v1\nkind: Secret\nmetadata:\n  name: mon-projet-secret\ntype: Opaque\nstringData:\n  jwt-secret: \"&lt;votre_secret_base64&gt;\"\n  db-password: \"postgres\"\n</code></pre> <pre><code>kubectl apply -f k8s/secret.yaml\n</code></pre>"},{"location":"generated-project-guide/#deployment","title":"Deployment","text":"<pre><code># k8s/deployment.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: mon-projet\n  labels:\n    app: mon-projet\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: mon-projet\n  template:\n    metadata:\n      labels:\n        app: mon-projet\n    spec:\n      containers:\n      - name: mon-projet\n        image: mon-projet:latest\n        ports:\n        - containerPort: 8080\n        env:\n        - name: APP_PORT\n          value: \"8080\"\n        - name: DB_HOST\n          value: postgres-service\n        - name: DB_USER\n          value: postgres\n        - name: DB_NAME\n          value: mon-projet\n        - name: DB_PASSWORD\n          valueFrom:\n            secretKeyRef:\n              name: mon-projet-secret\n              key: db-password\n        - name: JWT_SECRET\n          valueFrom:\n            secretKeyRef:\n              name: mon-projet-secret\n              key: jwt-secret\n        livenessProbe:\n          httpGet:\n            path: /health\n            port: 8080\n          initialDelaySeconds: 10\n          periodSeconds: 30\n        readinessProbe:\n          httpGet:\n            path: /health\n            port: 8080\n          initialDelaySeconds: 5\n          periodSeconds: 10\n        resources:\n          requests:\n            memory: \"128Mi\"\n            cpu: \"100m\"\n          limits:\n            memory: \"256Mi\"\n            cpu: \"500m\"\n</code></pre> <pre><code>kubectl apply -f k8s/deployment.yaml\n</code></pre>"},{"location":"generated-project-guide/#service","title":"Service","text":"<pre><code># k8s/service.yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: mon-projet-service\nspec:\n  selector:\n    app: mon-projet\n  ports:\n  - port: 80\n    targetPort: 8080\n    protocol: TCP\n  type: LoadBalancer\n</code></pre> <pre><code>kubectl apply -f k8s/service.yaml\n</code></pre>"},{"location":"generated-project-guide/#deployer-postgresql-statefulset","title":"D\u00e9ployer PostgreSQL (StatefulSet)","text":"<pre><code># k8s/postgres.yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: postgres-service\nspec:\n  selector:\n    app: postgres\n  ports:\n  - port: 5432\n  clusterIP: None\n---\napiVersion: apps/v1\nkind: StatefulSet\nmetadata:\n  name: postgres\nspec:\n  serviceName: postgres-service\n  replicas: 1\n  selector:\n    matchLabels:\n      app: postgres\n  template:\n    metadata:\n      labels:\n        app: postgres\n    spec:\n      containers:\n      - name: postgres\n        image: postgres:16-alpine\n        ports:\n        - containerPort: 5432\n        env:\n        - name: POSTGRES_DB\n          value: mon-projet\n        - name: POSTGRES_USER\n          value: postgres\n        - name: POSTGRES_PASSWORD\n          valueFrom:\n            secretKeyRef:\n              name: mon-projet-secret\n              key: db-password\n        volumeMounts:\n        - name: postgres-storage\n          mountPath: /var/lib/postgresql/data\n  volumeClaimTemplates:\n  - metadata:\n      name: postgres-storage\n    spec:\n      accessModes: [\"ReadWriteOnce\"]\n      resources:\n        requests:\n          storage: 10Gi\n</code></pre> <pre><code>kubectl apply -f k8s/postgres.yaml\n</code></pre>"},{"location":"generated-project-guide/#cicd-avec-github-actions","title":"CI/CD avec GitHub Actions","text":"<p>Le workflow g\u00e9n\u00e9r\u00e9 (<code>.github/workflows/ci.yml</code>):</p> <pre><code>name: CI\n\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main]\n\njobs:\n  quality:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n\n    - name: Set up Go\n      uses: actions/setup-go@v4\n      with:\n        go-version: '1.25'\n\n    - name: golangci-lint\n      uses: golangci/golangci-lint-action@v3\n      with:\n        version: latest\n\n  test:\n    runs-on: ubuntu-latest\n\n    services:\n      postgres:\n        image: postgres:16-alpine\n        env:\n          POSTGRES_DB: test_db\n          POSTGRES_USER: postgres\n          POSTGRES_PASSWORD: postgres\n        options: &gt;-\n          --health-cmd pg_isready\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n        ports:\n          - 5432:5432\n\n    steps:\n    - uses: actions/checkout@v3\n\n    - name: Set up Go\n      uses: actions/setup-go@v4\n      with:\n        go-version: '1.25'\n\n    - name: Run tests\n      env:\n        DB_HOST: localhost\n        DB_PORT: 5432\n        DB_USER: postgres\n        DB_PASSWORD: postgres\n        DB_NAME: test_db\n        JWT_SECRET: test-secret\n      run: go test -v -race -coverprofile=coverage.out ./...\n\n    - name: Upload coverage\n      uses: codecov/codecov-action@v3\n      with:\n        files: ./coverage.out\n\n  build:\n    runs-on: ubuntu-latest\n    needs: [quality, test]\n    steps:\n    - uses: actions/checkout@v3\n\n    - name: Set up Go\n      uses: actions/setup-go@v4\n      with:\n        go-version: '1.25'\n\n    - name: Build\n      run: go build -v -o mon-projet cmd/main.go\n</code></pre> <p>Pipeline: 1. Quality: golangci-lint 2. Test: Tests avec PostgreSQL (service container) 3. Build: V\u00e9rification build</p>"},{"location":"generated-project-guide/#deploiement-en-production","title":"D\u00e9ploiement en production","text":""},{"location":"generated-project-guide/#checklist-pre-deploiement","title":"Checklist pr\u00e9-d\u00e9ploiement","text":"<ul> <li> Tous les tests passent (<code>make test</code>)</li> <li> Lint passe (<code>make lint</code>)</li> <li> Variables d'environnement configur\u00e9es</li> <li> JWT_SECRET g\u00e9n\u00e9r\u00e9 (fort, al\u00e9atoire)</li> <li> DB_SSLMODE=require</li> <li> Migrations DB ex\u00e9cut\u00e9es</li> <li> Health check fonctionne</li> <li> Logs configur\u00e9s</li> <li> Monitoring en place</li> </ul>"},{"location":"generated-project-guide/#plateformes-recommandees","title":"Plateformes recommand\u00e9es","text":"<p>1. Google Cloud Run (le plus simple):</p> <pre><code># Build et push image\ngcloud builds submit --tag gcr.io/PROJECT_ID/mon-projet\n\n# Deploy\ngcloud run deploy mon-projet \\\n  --image gcr.io/PROJECT_ID/mon-projet \\\n  --platform managed \\\n  --region us-central1 \\\n  --allow-unauthenticated \\\n  --set-env-vars JWT_SECRET=$JWT_SECRET,DB_HOST=$DB_HOST\n</code></pre> <p>2. AWS ECS/Fargate:</p> <ul> <li>Build image \u2192 Push to ECR</li> <li>Create Task Definition</li> <li>Create ECS Service</li> <li>Configure ALB</li> </ul> <p>3. Heroku:</p> <pre><code># Login\nheroku login\n\n# Create app\nheroku create mon-projet\n\n# Add PostgreSQL\nheroku addons:create heroku-postgresql:hobby-dev\n\n# Set env vars\nheroku config:set JWT_SECRET=$(openssl rand -base64 32)\n\n# Deploy\ngit push heroku main\n</code></pre> <p>4. Kubernetes (le plus flexible):</p> <pre><code># Apply all manifests\nkubectl apply -f k8s/\n\n# Check status\nkubectl get pods\nkubectl get services\n\n# View logs\nkubectl logs -f deployment/mon-projet\n</code></pre>"},{"location":"generated-project-guide/#monitoring-logging","title":"Monitoring &amp; Logging","text":""},{"location":"generated-project-guide/#logging-avec-zerolog","title":"Logging avec zerolog","text":""},{"location":"generated-project-guide/#configuration_1","title":"Configuration","text":"<p>Le logger est configur\u00e9 dans <code>pkg/logger/logger.go</code>:</p> <pre><code>func NewLogger(config *config.Config) zerolog.Logger {\n    zerolog.TimeFieldFormat = zerolog.TimeFormatUnix\n\n    var logger zerolog.Logger\n\n    if config.AppEnv == \"production\" {\n        logger = zerolog.New(os.Stdout).With().Timestamp().Logger()\n    } else {\n        logger = zerolog.New(zerolog.ConsoleWriter{Out: os.Stdout}).\n            With().\n            Timestamp().\n            Logger()\n    }\n\n    // Set level based on env\n    switch config.AppEnv {\n    case \"production\":\n        zerolog.SetGlobalLevel(zerolog.InfoLevel)\n    case \"development\":\n        zerolog.SetGlobalLevel(zerolog.DebugLevel)\n    default:\n        zerolog.SetGlobalLevel(zerolog.InfoLevel)\n    }\n\n    return logger\n}\n</code></pre>"},{"location":"generated-project-guide/#utilisation","title":"Utilisation","text":"<p>Injection via fx:</p> <pre><code>type UserService struct {\n    logger zerolog.Logger\n}\n\nfunc NewUserService(logger zerolog.Logger) *UserService {\n    return &amp;UserService{logger: logger}\n}\n</code></pre> <p>Logging structur\u00e9:</p> <pre><code>// Info\nlogger.Info().\n    Str(\"email\", user.Email).\n    Uint(\"user_id\", user.ID).\n    Msg(\"User registered successfully\")\n\n// Error\nlogger.Error().\n    Err(err).\n    Str(\"operation\", \"create_user\").\n    Str(\"email\", email).\n    Msg(\"Failed to create user\")\n\n// Debug\nlogger.Debug().\n    Interface(\"request\", req).\n    Msg(\"Received request\")\n\n// Warn\nlogger.Warn().\n    Dur(\"duration\", elapsed).\n    Msg(\"Slow query detected\")\n\n// Fatal (exits)\nlogger.Fatal().\n    Err(err).\n    Msg(\"Cannot connect to database\")\n</code></pre>"},{"location":"generated-project-guide/#niveaux-de-log","title":"Niveaux de log","text":"Niveau Usage Debug Informations d\u00e9taill\u00e9es pour debugging Info \u00c9v\u00e9nements importants (user login, etc.) Warn Comportements anormaux non-critiques Error Erreurs n\u00e9cessitant attention Fatal Erreurs critiques (app exit)"},{"location":"generated-project-guide/#best-practices","title":"Best practices","text":"<p>\u2705 BON - Structured logging:</p> <pre><code>logger.Info().\n    Str(\"user_id\", userID).\n    Str(\"action\", \"login\").\n    Dur(\"duration\", elapsed).\n    Msg(\"User logged in\")\n</code></pre> <p>\u274c MAUVAIS - String formatting:</p> <pre><code>logger.Info().Msgf(\"User %s logged in after %v\", userID, elapsed)\n</code></pre> <p>\u2705 BON - Pas de secrets:</p> <pre><code>logger.Info().Str(\"email\", email).Msg(\"User login attempt\")\n</code></pre> <p>\u274c MAUVAIS - Logging secrets:</p> <pre><code>logger.Info().Str(\"password\", password).Msg(\"Login\")  // NEVER!\n</code></pre>"},{"location":"generated-project-guide/#monitoring-recommandations","title":"Monitoring (recommandations)","text":"<p>Pour la production, int\u00e9grer:</p>"},{"location":"generated-project-guide/#1-prometheus-grafana","title":"1. Prometheus + Grafana","text":"<p>Metrics \u00e0 collecter: - Request rate (requests/sec) - Response time (p50, p95, p99) - Error rate (%) - Database connection pool - CPU/Memory usage</p> <p>Impl\u00e9menter avec fiber/prometheus:</p> <pre><code>import \"github.com/gofiber/adaptor/v2\"\nimport \"github.com/prometheus/client_golang/prometheus/promhttp\"\n\napp.Get(\"/metrics\", adaptor.HTTPHandler(promhttp.Handler()))\n</code></pre>"},{"location":"generated-project-guide/#2-jaeger-opentelemetry","title":"2. Jaeger / OpenTelemetry","text":"<p>Distributed tracing pour suivre les requ\u00eates \u00e0 travers les services.</p>"},{"location":"generated-project-guide/#3-sentry","title":"3. Sentry","text":"<p>Error tracking en temps r\u00e9el:</p> <pre><code>import \"github.com/getsentry/sentry-go\"\n\nsentry.Init(sentry.ClientOptions{\n    Dsn: os.Getenv(\"SENTRY_DSN\"),\n})\n\n// Capture errors\nsentry.CaptureException(err)\n</code></pre>"},{"location":"generated-project-guide/#4-apm-application-performance-monitoring","title":"4. APM (Application Performance Monitoring)","text":"<ul> <li>New Relic: APM complet</li> <li>Datadog: Monitoring + logs</li> <li>Elastic APM: Open source</li> </ul>"},{"location":"generated-project-guide/#health-checks","title":"Health checks","text":"<p>L'endpoint <code>/health</code> est crucial pour:</p> <ul> <li>Load balancers</li> <li>Kubernetes probes</li> <li>Monitoring tools</li> </ul> <p>Am\u00e9lior\u00e9:</p> <pre><code>type HealthResponse struct {\n    Status   string            `json:\"status\"`\n    Version  string            `json:\"version\"`\n    Services map[string]string `json:\"services\"`\n}\n\nfunc (h *HealthHandler) Check(c *fiber.Ctx) error {\n    // Check database\n    dbStatus := \"ok\"\n    if err := h.db.Exec(\"SELECT 1\").Error; err != nil {\n        dbStatus = \"error\"\n    }\n\n    response := HealthResponse{\n        Status:  \"ok\",\n        Version: \"1.0.0\",\n        Services: map[string]string{\n            \"database\": dbStatus,\n        },\n    }\n\n    if dbStatus != \"ok\" {\n        return c.Status(fiber.StatusServiceUnavailable).JSON(response)\n    }\n\n    return c.JSON(response)\n}\n</code></pre>"},{"location":"generated-project-guide/#bonnes-pratiques","title":"Bonnes pratiques","text":""},{"location":"generated-project-guide/#architecture_1","title":"Architecture","text":"<p>1. Domain isolation</p> <p>Le domaine ne doit jamais importer d'autres packages:</p> <pre><code>// \u274c BAD - Domain importing adapter\npackage user\n\nimport \"mon-projet/internal/adapters/repository\"  // NO!\n\n// \u2705 GOOD - Domain only imports interfaces\npackage user\n\nimport \"mon-projet/internal/interfaces\"\n</code></pre> <p>2. Single Responsibility Principle</p> <p>Chaque composant a une seule responsabilit\u00e9:</p> <ul> <li>Handlers: Parse + validate + call service</li> <li>Services: Business logic uniquement</li> <li>Repositories: Data access uniquement</li> </ul> <p>3. Dependency Injection</p> <p>Toujours via fx.Provide, pas de variables globales:</p> <pre><code>// \u274c BAD - Global variable\nvar db *gorm.DB\n\n// \u2705 GOOD - Injection\ntype UserService struct {\n    db *gorm.DB\n}\n\nfunc NewUserService(db *gorm.DB) *UserService {\n    return &amp;UserService{db: db}\n}\n</code></pre>"},{"location":"generated-project-guide/#code-style","title":"Code style","text":"<p>1. gofmt</p> <p>Toujours formater:</p> <pre><code>go fmt ./...\n</code></pre> <p>Ou configurer l'IDE pour formater \u00e0 la sauvegarde.</p> <p>2. golangci-lint</p> <p>Respecter les r\u00e8gles:</p> <pre><code>make lint\n</code></pre> <p>3. Documentation GoDoc</p> <p>Pour les exports publics:</p> <pre><code>// UserService handles user-related business logic.\n// It provides methods for user registration, authentication, and CRUD operations.\ntype UserService struct {\n    repo   interfaces.UserRepository\n    logger zerolog.Logger\n}\n\n// Register creates a new user with the provided email and password.\n// The password is automatically hashed before storage.\n// Returns an error if the email already exists or if validation fails.\nfunc (s *UserService) Register(ctx context.Context, email, password string) (*User, error) {\n    // ...\n}\n</code></pre> <p>4. Error handling explicite</p> <p>Toujours g\u00e9rer les erreurs, ne pas utiliser <code>panic</code>:</p> <pre><code>// \u274c BAD\nuser := getUserByID(id)  // What if error?\n\n// \u2705 GOOD\nuser, err := getUserByID(id)\nif err != nil {\n    return nil, fmt.Errorf(\"failed to get user: %w\", err)\n}\n</code></pre>"},{"location":"generated-project-guide/#naming-conventions","title":"Naming conventions","text":"<p>Interfaces: - Suffixe <code>-er</code> ou <code>-Service</code> - Exemples: <code>UserRepository</code>, <code>AuthService</code>, <code>Logger</code></p> <p>Repositories: - Suffixe <code>-Repository</code> - Exemples: <code>UserRepository</code>, <code>ProductRepository</code></p> <p>Handlers: - Suffixe <code>-Handler</code> - Exemples: <code>AuthHandler</code>, <code>UserHandler</code></p> <p>Constructeurs: - Pr\u00e9fixe <code>New</code> - Exemples: <code>NewUserService</code>, <code>NewAuthHandler</code></p> <p>M\u00e9thodes priv\u00e9es: - lowerCamelCase - Exemples: <code>hashPassword</code>, <code>validateEmail</code></p>"},{"location":"generated-project-guide/#error-handling-patterns","title":"Error handling patterns","text":"<p>Wrap errors avec contexte:</p> <pre><code>// \u2705 GOOD\nif err != nil {\n    return fmt.Errorf(\"failed to create user %s: %w\", email, err)\n}\n</code></pre> <p>Domain errors pour logique m\u00e9tier:</p> <pre><code>if user == nil {\n    return domain.NewNotFoundError(\"User not found\", \"USER_NOT_FOUND\", nil)\n}\n</code></pre> <p>Ne pas g\u00e9rer les HTTP status dans le service:</p> <pre><code>// \u274c BAD - Service returning HTTP status\nfunc (s *UserService) GetByID(id uint) (int, *User, error) {\n    return 404, nil, errors.New(\"not found\")\n}\n\n// \u2705 GOOD - Service returning domain error\nfunc (s *UserService) GetByID(id uint) (*User, error) {\n    return nil, domain.NewNotFoundError(\"User not found\", \"USER_NOT_FOUND\", nil)\n}\n</code></pre>"},{"location":"generated-project-guide/#testing-best-practices","title":"Testing best practices","text":"<p>1. Coverage &gt; 80%</p> <pre><code>go test -cover ./...\n</code></pre> <p>2. Tests table-driven</p> <pre><code>tests := []struct {\n    name    string\n    input   string\n    want    string\n    wantErr bool\n}{\n    {\"valid\", \"test\", \"TEST\", false},\n    {\"empty\", \"\", \"\", true},\n}\n\nfor _, tt := range tests {\n    t.Run(tt.name, func(t *testing.T) {\n        got, err := ToUpper(tt.input)\n        if tt.wantErr {\n            assert.Error(t, err)\n        } else {\n            assert.Equal(t, tt.want, got)\n        }\n    })\n}\n</code></pre> <p>3. Noms descriptifs</p> <pre><code>func TestUserService_Register_WhenEmailAlreadyExists_ReturnsConflictError(t *testing.T)\n</code></pre> <p>4. Setup/teardown avec t.Cleanup()</p> <pre><code>func TestSomething(t *testing.T) {\n    db := setupTestDB(t)\n    t.Cleanup(func() {\n        db.Exec(\"DELETE FROM users\")\n        db.Close()\n    })\n\n    // Test code\n}\n</code></pre>"},{"location":"generated-project-guide/#performance","title":"Performance","text":"<p>1. GORM - \u00c9viter N+1 queries</p> <pre><code>// \u274c N+1 problem\nfor _, user := range users {\n    db.Model(&amp;user).Association(\"Posts\").Find(&amp;posts)\n}\n\n// \u2705 Single query with Preload\ndb.Preload(\"Posts\").Find(&amp;users)\n</code></pre> <p>2. Context - Toujours passer context.Context</p> <pre><code>func (s *UserService) GetByID(ctx context.Context, id uint) (*User, error) {\n    return s.repo.FindByID(ctx, id)\n}\n</code></pre> <p>3. Database indexes</p> <pre><code>Email string `gorm:\"uniqueIndex\"`  // Index sur colonnes fr\u00e9quemment requ\u00eat\u00e9es\n</code></pre> <p>4. Connection pooling</p> <pre><code>sqlDB, _ := db.DB()\nsqlDB.SetMaxIdleConns(10)\nsqlDB.SetMaxOpenConns(100)\nsqlDB.SetConnMaxLifetime(time.Hour)\n</code></pre>"},{"location":"generated-project-guide/#securite-recap","title":"S\u00e9curit\u00e9 recap","text":"<ul> <li> Valider toutes les entr\u00e9es utilisateur</li> <li> Jamais logger de passwords ou tokens</li> <li> Rate limiting sur endpoints publics</li> <li> HTTPS en production</li> <li> JWT secret fort (32+ caract\u00e8res)</li> <li> Bcrypt pour passwords</li> <li> Mettre \u00e0 jour les d\u00e9pendances r\u00e9guli\u00e8rement</li> </ul> <pre><code># V\u00e9rifier vuln\u00e9rabilit\u00e9s\ngo list -json -m all | nancy sleuth\n</code></pre>"},{"location":"generated-project-guide/#conclusion","title":"Conclusion","text":"<p>Ce guide couvre tous les aspects du d\u00e9veloppement avec les projets g\u00e9n\u00e9r\u00e9s par <code>create-go-starter</code>. Pour aller plus loin:</p> <ul> <li>Exemples de code: Tous les patterns sont dans le code g\u00e9n\u00e9r\u00e9</li> <li>Tests: Regardez les fichiers <code>*_test.go</code> pour des exemples</li> <li>Documentation officielle:</li> <li>Fiber</li> <li>GORM</li> <li>fx</li> <li>zerolog</li> </ul> <p>Bon d\u00e9veloppement! \ud83d\ude80</p> <p>Si vous rencontrez des probl\u00e8mes ou avez des questions, consultez: - Issues GitHub - Discussions GitHub</p>"},{"location":"installation/","title":"Guide d'installation","text":"<p>Ce guide d\u00e9taille toutes les m\u00e9thodes pour installer <code>create-go-starter</code> sur votre syst\u00e8me.</p>"},{"location":"installation/#prerequis","title":"Pr\u00e9requis","text":""},{"location":"installation/#systeme-requis","title":"Syst\u00e8me requis","text":"<ul> <li>Go 1.25 ou sup\u00e9rieur - V\u00e9rifiez votre version avec <code>go version</code></li> <li>Git - Pour cloner le repository</li> <li>Espace disque - ~50MB pour l'outil et ses d\u00e9pendances</li> </ul>"},{"location":"installation/#verifier-linstallation-de-go","title":"V\u00e9rifier l'installation de Go","text":"<pre><code>go version\n# Devrait afficher: go version go1.25.x ...\n</code></pre> <p>Si Go n'est pas install\u00e9, t\u00e9l\u00e9chargez-le depuis golang.org/dl.</p>"},{"location":"installation/#configurer-gopath-et-path","title":"Configurer GOPATH et PATH","text":"<p>Assurez-vous que <code>$GOPATH/bin</code> est dans votre <code>PATH</code>:</p> <pre><code># V\u00e9rifier GOPATH\ngo env GOPATH\n# G\u00e9n\u00e9ralement: /Users/&lt;username&gt;/go sur macOS\n#              $HOME/go sur Linux\n#              C:\\Users\\&lt;username&gt;\\go sur Windows\n\n# Ajouter \u00e0 PATH si n\u00e9cessaire (dans ~/.zshrc, ~/.bashrc, ou ~/.bash_profile)\nexport PATH=$PATH:$(go env GOPATH)/bin\n</code></pre> <p>Apr\u00e8s modification, rechargez votre shell:</p> <pre><code>source ~/.zshrc  # ou ~/.bashrc selon votre shell\n</code></pre>"},{"location":"installation/#outils-optionnels-recommandes","title":"Outils optionnels (recommand\u00e9s)","text":"<ul> <li> <p>golangci-lint - Pour le d\u00e9veloppement et contribution   <pre><code># macOS avec Homebrew\nbrew install golangci-lint\n\n# Linux\ncurl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- -b $(go env GOPATH)/bin\n\n# Ou avec go install\ngo install github.com/golangci/golangci-lint/cmd/golangci-lint@latest\n</code></pre></p> </li> <li> <p>Docker - Pour tester les projets g\u00e9n\u00e9r\u00e9s   <pre><code># macOS avec Homebrew\nbrew install --cask docker\n\n# Linux: Suivez les instructions officielles\n# https://docs.docker.com/engine/install/\n</code></pre></p> </li> </ul>"},{"location":"installation/#methode-1-installation-directe-recommandee","title":"M\u00e9thode 1: Installation directe (Recommand\u00e9e)","text":"<p>C'est la m\u00e9thode la plus simple et recommand\u00e9e. Installation globale en une seule commande, sans cloner le repository.</p>"},{"location":"installation/#installation-en-une-commande","title":"Installation en une commande","text":"<pre><code>go install github.com/tky0065/go-starter-kit/cmd/create-go-starter@latest\n</code></pre> <p>Cette commande: - T\u00e9l\u00e9charge automatiquement le code depuis GitHub - Compile le binaire - L'installe dans <code>$GOPATH/bin</code> (g\u00e9n\u00e9ralement <code>~/go/bin</code>) - Le rend disponible globalement</p>"},{"location":"installation/#verification","title":"V\u00e9rification","text":"<pre><code>create-go-starter --help\n</code></pre> <p>Vous devriez voir l'aide de l'outil s'afficher.</p> <p>Note: Assurez-vous que <code>$GOPATH/bin</code> est dans votre <code>PATH</code>. Sinon:</p> <pre><code>export PATH=$PATH:$(go env GOPATH)/bin\n</code></pre>"},{"location":"installation/#localisation-du-binaire","title":"Localisation du binaire","text":"<p>Le binaire est install\u00e9 dans: - macOS/Linux: <code>~/go/bin/create-go-starter</code> - Windows: <code>C:\\Users\\&lt;username&gt;\\go\\bin\\create-go-starter.exe</code></p>"},{"location":"installation/#avantages-de-cette-methode","title":"Avantages de cette m\u00e9thode","text":"<ul> <li>Ultra simple - Une seule commande</li> <li>Pas besoin de cloner - Go g\u00e8re tout automatiquement</li> <li>Toujours \u00e0 jour - Utilisez <code>@latest</code> pour la derni\u00e8re version</li> <li>Binaire disponible globalement</li> <li>M\u00e9thode standard de l'\u00e9cosyst\u00e8me Go</li> </ul>"},{"location":"installation/#methode-2-installation-depuis-les-sources","title":"M\u00e9thode 2: Installation depuis les sources","text":"<p>Cette m\u00e9thode est recommand\u00e9e pour les contributeurs ou si vous voulez personnaliser l'outil.</p>"},{"location":"installation/#etapes","title":"\u00c9tapes","text":"<ol> <li>Cloner le repository</li> </ol> <pre><code>git clone https://github.com/tky0065/go-starter-kit.git\ncd go-starter-kit\n</code></pre> <ol> <li>Build avec go build</li> </ol> <pre><code>go build -o create-go-starter ./cmd/create-go-starter\n</code></pre> <p>Le binaire <code>create-go-starter</code> sera cr\u00e9\u00e9 dans le r\u00e9pertoire courant.</p> <ol> <li>Ou build avec Makefile</li> </ol> <pre><code>make build\n</code></pre> <p>Le binaire sera cr\u00e9\u00e9 dans le r\u00e9pertoire courant.</p> <ol> <li>Installation manuelle (optionnel)</li> </ol> <p>Pour rendre le binaire disponible globalement:</p> <pre><code># Option A: Copier vers $GOPATH/bin\ncp create-go-starter $(go env GOPATH)/bin/\n\n# Option B: Copier vers /usr/local/bin (n\u00e9cessite sudo sur macOS/Linux)\nsudo cp create-go-starter /usr/local/bin/\n\n# Option C: Ajouter le r\u00e9pertoire actuel \u00e0 PATH\nexport PATH=$PATH:$(pwd)  # Ajouter ceci dans ~/.zshrc pour le rendre permanent\n</code></pre> <ol> <li>V\u00e9rifier l'installation</li> </ol> <pre><code># Si install\u00e9 globalement\ncreate-go-starter --help\n\n# Ou utiliser le chemin relatif\n./create-go-starter --help\n</code></pre>"},{"location":"installation/#avantages-de-cette-methode_1","title":"Avantages de cette m\u00e9thode","text":"<ul> <li>Contr\u00f4le total sur le build</li> <li>Facile de modifier le code source</li> <li>Id\u00e9al pour le d\u00e9veloppement et les tests</li> <li>Permet de cr\u00e9er des builds personnalis\u00e9s</li> </ul>"},{"location":"installation/#build-avec-options-avancees","title":"Build avec options avanc\u00e9es","text":"<pre><code># Build avec optimisations pour production\ngo build -ldflags=\"-s -w\" -o create-go-starter ./cmd/create-go-starter\n\n# Build pour un OS/architecture sp\u00e9cifique\nGOOS=linux GOARCH=amd64 go build -o create-go-starter-linux ./cmd/create-go-starter\nGOOS=windows GOARCH=amd64 go build -o create-go-starter.exe ./cmd/create-go-starter\nGOOS=darwin GOARCH=arm64 go build -o create-go-starter-macos-arm ./cmd/create-go-starter\n</code></pre>"},{"location":"installation/#methode-3-binaire-pre-compile-a-venir","title":"M\u00e9thode 3: Binaire pr\u00e9-compil\u00e9 (\u00c0 venir)","text":"<p>Note: Cette m\u00e9thode sera disponible une fois que le projet publiera des releases avec des binaires pr\u00e9-compil\u00e9s.</p> <p>Lorsque disponible, vous pourrez t\u00e9l\u00e9charger les binaires depuis la page Releases.</p>"},{"location":"installation/#installation-sur-macoslinux","title":"Installation sur macOS/Linux","text":"<pre><code># T\u00e9l\u00e9charger le binaire (remplacez VERSION par la version souhait\u00e9e)\ncurl -L https://github.com/tky0065/go-starter-kit/releases/download/vVERSION/create-go-starter-macos -o create-go-starter\n\n# Donner les permissions d'ex\u00e9cution\nchmod +x create-go-starter\n\n# D\u00e9placer vers un r\u00e9pertoire dans PATH\nsudo mv create-go-starter /usr/local/bin/\n</code></pre>"},{"location":"installation/#installation-sur-windows","title":"Installation sur Windows","text":"<ol> <li>T\u00e9l\u00e9chargez <code>create-go-starter.exe</code> depuis la page Releases</li> <li>Placez le fichier dans un r\u00e9pertoire de votre choix</li> <li>Ajoutez ce r\u00e9pertoire \u00e0 votre variable PATH syst\u00e8me</li> </ol>"},{"location":"installation/#verification-de-linstallation","title":"V\u00e9rification de l'installation","text":"<p>Apr\u00e8s installation, v\u00e9rifiez que l'outil fonctionne correctement:</p> <pre><code># Afficher l'aide\ncreate-go-starter --help\n\n# Devrait afficher quelque chose comme:\n# Usage: create-go-starter &lt;project-name&gt;\n#   -h, --help    Show this help message\n</code></pre>"},{"location":"installation/#test-de-creation-de-projet","title":"Test de cr\u00e9ation de projet","text":"<p>Testez en cr\u00e9ant un projet simple:</p> <pre><code># Cr\u00e9er un projet test\ncreate-go-starter test-project\n\n# V\u00e9rifier que le projet a \u00e9t\u00e9 cr\u00e9\u00e9\nls -la test-project/\n\n# Nettoyer\nrm -rf test-project\n</code></pre> <p>Si vous voyez la structure du projet cr\u00e9\u00e9e avec succ\u00e8s (en vert dans le terminal), l'installation fonctionne parfaitement!</p>"},{"location":"installation/#mise-a-jour","title":"Mise \u00e0 jour","text":""},{"location":"installation/#mise-a-jour-via-go-install-methode-1","title":"Mise \u00e0 jour via go install (M\u00e9thode 1)","text":"<p>Si vous avez install\u00e9 avec la M\u00e9thode 1 (installation directe), r\u00e9ex\u00e9cutez simplement la commande:</p> <pre><code>go install github.com/tky0065/go-starter-kit/cmd/create-go-starter@latest\n</code></pre> <p>Go t\u00e9l\u00e9chargera et installera automatiquement la derni\u00e8re version disponible. C'est la m\u00e9thode la plus simple!</p>"},{"location":"installation/#mise-a-jour-depuis-les-sources-methode-2","title":"Mise \u00e0 jour depuis les sources (M\u00e9thode 2)","text":"<p>Si vous avez install\u00e9 depuis les sources:</p> <pre><code># Se placer dans le repository\ncd /path/to/go-starter-kit\n\n# R\u00e9cup\u00e9rer les derni\u00e8res modifications\ngit pull origin main\n\n# Rebuild\nmake build  # ou go build -o create-go-starter ./cmd/create-go-starter\n\n# R\u00e9installer si n\u00e9cessaire\ncp create-go-starter $(go env GOPATH)/bin/\n</code></pre>"},{"location":"installation/#verifier-la-version","title":"V\u00e9rifier la version","text":"<p>Note: La commande <code>--version</code> n'est pas encore impl\u00e9ment\u00e9e dans la version actuelle.</p> <p>Une fois impl\u00e9ment\u00e9e:</p> <pre><code>create-go-starter --version\n</code></pre> <p>Pour l'instant, v\u00e9rifiez le commit Git:</p> <pre><code>cd /path/to/go-starter-kit\ngit log -1 --oneline\n</code></pre>"},{"location":"installation/#desinstallation","title":"D\u00e9sinstallation","text":""},{"location":"installation/#si-installe-via-go-install-ou-copie-manuelle","title":"Si install\u00e9 via go install ou copie manuelle","text":"<pre><code># Supprimer le binaire\nrm $(go env GOPATH)/bin/create-go-starter\n\n# Ou si install\u00e9 dans /usr/local/bin\nsudo rm /usr/local/bin/create-go-starter\n</code></pre>"},{"location":"installation/#si-installe-depuis-les-sources-dans-le-repository","title":"Si install\u00e9 depuis les sources (dans le repository)","text":"<pre><code># Supprimer le binaire local\ncd /path/to/go-starter-kit\nrm create-go-starter\n\n# Optionnel: Supprimer le repository complet\ncd ..\nrm -rf go-starter-kit\n</code></pre>"},{"location":"installation/#nettoyer-le-cache-go","title":"Nettoyer le cache Go","text":"<p>Pour lib\u00e9rer de l'espace:</p> <pre><code># Nettoyer le cache de modules\ngo clean -modcache\n\n# Nettoyer le cache de build\ngo clean -cache\n</code></pre>"},{"location":"installation/#resolution-de-problemes","title":"R\u00e9solution de probl\u00e8mes","text":""},{"location":"installation/#probleme-command-not-found-create-go-starter","title":"Probl\u00e8me: \"command not found: create-go-starter\"","text":"<p>Causes possibles: 1. <code>$GOPATH/bin</code> n'est pas dans votre <code>PATH</code> 2. Le binaire n'a pas \u00e9t\u00e9 install\u00e9 correctement 3. Le cache du shell n'a pas \u00e9t\u00e9 recharg\u00e9 (cause la plus fr\u00e9quente)</p> <p>Solutions:</p> <p>Solution 1: Recharger le cache du shell (\u26a1 Rapide - Essayez \u00e7a d'abord!)</p> <p>Apr\u00e8s <code>go install</code>, votre shell (zsh/bash) peut avoir une version en cache de la liste des commandes disponibles. Rechargez-la :</p> <pre><code># Pour zsh et bash\nhash -r\n\n# Puis v\u00e9rifier\nwhich create-go-starter\ncreate-go-starter --help\n</code></pre> <p>Solution 2: Red\u00e9marrer le terminal</p> <p>Fermez et rouvrez votre terminal. C'est souvent la solution la plus simple !</p> <p>Solution 3: V\u00e9rifier et configurer le PATH</p> <p>Si les solutions pr\u00e9c\u00e9dentes ne fonctionnent pas :</p> <pre><code># V\u00e9rifier GOPATH\ngo env GOPATH\n\n# V\u00e9rifier si le binaire existe\nls -l $(go env GOPATH)/bin/create-go-starter\n\n# V\u00e9rifier si GOPATH/bin est dans PATH\necho $PATH | grep \"$(go env GOPATH)/bin\"\n\n# Si absent, ajouter GOPATH/bin au PATH (dans ~/.zshrc ou ~/.bashrc)\nexport PATH=$PATH:$(go env GOPATH)/bin\n\n# Recharger le shell\nsource ~/.zshrc  # ou ~/.bashrc\n</code></pre> <p>Solution 4: Utiliser le chemin complet temporairement</p> <p>En attendant de r\u00e9soudre le PATH :</p> <pre><code>$(go env GOPATH)/bin/create-go-starter mon-projet\n</code></pre>"},{"location":"installation/#probleme-permission-denied-sur-macos","title":"Probl\u00e8me: \"permission denied\" sur macOS","text":"<p>Cause: macOS Gatekeeper bloque les binaires non sign\u00e9s.</p> <p>Solution:</p> <pre><code># Donner les permissions d'ex\u00e9cution\nchmod +x create-go-starter\n\n# Autoriser l'ex\u00e9cution (macOS)\nxattr -d com.apple.quarantine create-go-starter\n</code></pre> <p>Ou autorisez l'application dans: <code>Pr\u00e9f\u00e9rences Syst\u00e8me &gt; S\u00e9curit\u00e9 et confidentialit\u00e9 &gt; G\u00e9n\u00e9ral &gt; Autoriser quand m\u00eame</code></p>"},{"location":"installation/#probleme-erreurs-de-compilation","title":"Probl\u00e8me: Erreurs de compilation","text":"<p>Cause: Version de Go trop ancienne ou d\u00e9pendances manquantes.</p> <p>Solutions:</p> <pre><code># V\u00e9rifier la version de Go (doit \u00eatre &gt;= 1.25)\ngo version\n\n# Mettre \u00e0 jour les d\u00e9pendances\ngo mod tidy\ngo mod tidy\n\n# Nettoyer et rebuild\ngo clean\ngo build -o create-go-starter ./cmd/create-go-starter\n</code></pre>"},{"location":"installation/#probleme-go-cannot-find-main-module","title":"Probl\u00e8me: \"go: cannot find main module\"","text":"<p>Cause: Vous n'\u00eates pas dans le bon r\u00e9pertoire.</p> <p>Solution:</p> <pre><code># Assurez-vous d'\u00eatre dans le repository go-starter-kit\ncd /path/to/go-starter-kit\n\n# V\u00e9rifier que go.mod existe\nls go.mod\n\n# Puis r\u00e9essayer l'installation\ngo install ./cmd/create-go-starter\n</code></pre>"},{"location":"installation/#probleme-conflits-de-versions-go","title":"Probl\u00e8me: Conflits de versions Go","text":"<p>Cause: Plusieurs versions de Go install\u00e9es.</p> <p>Solutions:</p> <pre><code># V\u00e9rifier quelle version de Go est utilis\u00e9e\nwhich go\ngo version\n\n# Sur macOS avec Homebrew\nbrew list go\nbrew upgrade go\n\n# D\u00e9finir la version de Go \u00e0 utiliser (avec go.mod)\ncat go.mod | grep \"^go \"\n</code></pre>"},{"location":"installation/#probleme-build-lent","title":"Probl\u00e8me: Build lent","text":"<p>Solutions:</p> <pre><code># Activer le cache de build (devrait \u00eatre activ\u00e9 par d\u00e9faut)\ngo env GOCACHE\n\n# Build avec cache\ngo build -o create-go-starter ./cmd/create-go-starter\n\n# Si toujours lent, nettoyer puis rebuild\ngo clean -cache\ngo build -o create-go-starter ./cmd/create-go-starter\n</code></pre>"},{"location":"installation/#installation-pour-le-developpement","title":"Installation pour le d\u00e9veloppement","text":"<p>Si vous voulez contribuer au projet, suivez ces \u00e9tapes suppl\u00e9mentaires:</p> <pre><code># 1. Fork le repository sur GitHub\n# 2. Cloner votre fork\ngit clone https://github.com/tky0065/go-starter-kit.git\ncd go-starter-kit\n\n# 3. Ajouter le remote upstream\ngit remote add upstream https://github.com/tky0065/go-starter-kit.git\n\n# 4. Installer les d\u00e9pendances de d\u00e9veloppement\nmake install-dev  # ou installer golangci-lint manuellement\n\n# 5. Installer l'outil en mode dev\ngo install ./cmd/create-go-starter\n\n# 6. Cr\u00e9er une branche pour vos changements\ngit checkout -b feature/ma-fonctionnalite\n\n# 7. D\u00e9velopper, tester, commiter\nmake test\nmake lint\ngit commit -m \"feat: description de la fonctionnalit\u00e9\"\n\n# 8. Pousser et cr\u00e9er une PR\ngit push origin feature/ma-fonctionnalite\n</code></pre>"},{"location":"installation/#prochaines-etapes","title":"Prochaines \u00e9tapes","text":"<p>Maintenant que <code>create-go-starter</code> est install\u00e9, consultez:</p> <ul> <li>Guide d'utilisation - Apprendre \u00e0 utiliser l'outil</li> <li>Guide des projets g\u00e9n\u00e9r\u00e9s - D\u00e9velopper avec les projets cr\u00e9\u00e9s</li> <li>Guide de contribution - Contribuer au projet</li> </ul> <p>Ou commencez imm\u00e9diatement:</p> <pre><code>create-go-starter mon-premier-projet\ncd mon-premier-projet\n# Suivez les instructions affich\u00e9es!\n</code></pre> <p>Bon coding! \ud83d\ude80</p>"},{"location":"tutorial-exemple-complet/","title":"Tutorial: Cr\u00e9er une API Blog compl\u00e8te avec create-go-starter","text":"<p>Guide pas-\u00e0-pas pour cr\u00e9er une API Blog avec <code>create-go-starter</code>, de l'installation au d\u00e9ploiement.</p>"},{"location":"tutorial-exemple-complet/#table-des-matieres","title":"Table des mati\u00e8res","text":"<ol> <li>Objectif</li> <li>Pr\u00e9requis</li> <li>\u00c9tape 1: Installation du CLI</li> <li>\u00c9tape 2: G\u00e9n\u00e9ration du projet</li> <li>\u00c9tape 3: Configuration initiale</li> <li>\u00c9tape 4: Tester le projet de base</li> <li>\u00c9tape 5: Ajouter le domaine Post (Article)</li> <li>\u00c9tape 6: Impl\u00e9menter le service Post</li> <li>\u00c9tape 7: Cr\u00e9er le repository Post</li> <li>\u00c9tape 8: Cr\u00e9er le handler HTTP</li> <li>\u00c9tape 9: Enregistrer les routes et le module</li> <li>\u00c9tape 10: Tester l'API Posts</li> <li>\u00c9tape 11: Ajouter le domaine Comment</li> <li>\u00c9tape 12: Tests unitaires</li> <li>\u00c9tape 13: D\u00e9ploiement Docker</li> <li>Conclusion</li> </ol>"},{"location":"tutorial-exemple-complet/#objectif","title":"Objectif","text":"<p>Cr\u00e9er une API REST compl\u00e8te pour un blog avec:</p> <ul> <li>Articles (Posts) avec auteur, titre, contenu, tags</li> <li>Commentaires sur les articles</li> <li>Authentification JWT (d\u00e9j\u00e0 incluse dans create-go-starter)</li> <li>Tests complets</li> <li>D\u00e9ploiement Docker</li> </ul> <p>\u00c0 la fin de ce tutorial, vous aurez une API Blog production-ready avec toutes les bonnes pratiques.</p>"},{"location":"tutorial-exemple-complet/#prerequis","title":"Pr\u00e9requis","text":""},{"location":"tutorial-exemple-complet/#logiciels-requis","title":"Logiciels requis","text":"<ul> <li>Go 1.25+ - T\u00e9l\u00e9charger</li> <li>PostgreSQL ou Docker - Pour la base de donn\u00e9es</li> <li>curl ou Postman - Pour tester l'API</li> <li>\u00c9diteur de code (VS Code, GoLand, etc.)</li> </ul>"},{"location":"tutorial-exemple-complet/#connaissances-recommandees","title":"Connaissances recommand\u00e9es","text":"<ul> <li>Bases de Go (structs, interfaces, error handling)</li> <li>Concepts REST API</li> <li>Familiarit\u00e9 avec SQL/PostgreSQL (basique)</li> </ul> <p>Pas besoin d'\u00eatre expert! Ce tutorial explique chaque \u00e9tape en d\u00e9tail.</p>"},{"location":"tutorial-exemple-complet/#etape-1-installation-du-cli","title":"\u00c9tape 1: Installation du CLI","text":""},{"location":"tutorial-exemple-complet/#installation-globale-recommandee","title":"Installation globale (recommand\u00e9e)","text":"<p>La m\u00e9thode la plus simple pour installer <code>create-go-starter</code>:</p> <pre><code>go install github.com/tky0065/go-starter-kit/cmd/create-go-starter@latest\n</code></pre> <p>Cette commande t\u00e9l\u00e9charge, compile et installe le CLI globalement.</p>"},{"location":"tutorial-exemple-complet/#verification","title":"V\u00e9rification","text":"<pre><code>create-go-starter --help\n</code></pre> <p>Vous devriez voir l'aide s'afficher.</p> <p>Note: Si la commande n'est pas trouv\u00e9e, ajoutez <code>$GOPATH/bin</code> \u00e0 votre PATH:</p> <pre><code>export PATH=$PATH:$(go env GOPATH)/bin\n</code></pre>"},{"location":"tutorial-exemple-complet/#etape-2-generation-du-projet","title":"\u00c9tape 2: G\u00e9n\u00e9ration du projet","text":""},{"location":"tutorial-exemple-complet/#creer-le-projet","title":"Cr\u00e9er le projet","text":"<pre><code>create-go-starter blog-api\n</code></pre> <p>Cette commande g\u00e9n\u00e8re ~45 fichiers avec toute l'architecture n\u00e9cessaire.</p>"},{"location":"tutorial-exemple-complet/#structure-generee","title":"Structure g\u00e9n\u00e9r\u00e9e","text":"<pre><code>cd blog-api\ntree -L 3\n</code></pre> <p>R\u00e9sultat: <pre><code>blog-api/\n\u251c\u2500\u2500 cmd/\n\u2502   \u2514\u2500\u2500 main.go                       # Point d'entr\u00e9e avec fx DI\n\u251c\u2500\u2500 internal/\n\u2502   \u251c\u2500\u2500 models/\n\u2502   \u2502   \u2514\u2500\u2500 user.go                   # Entit\u00e9s: User, RefreshToken, AuthResponse\n\u2502   \u251c\u2500\u2500 domain/\n\u2502   \u2502   \u251c\u2500\u2500 user/                     # Domaine User (pr\u00e9-g\u00e9n\u00e9r\u00e9)\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 service.go\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 module.go\n\u2502   \u2502   \u2514\u2500\u2500 errors.go\n\u2502   \u251c\u2500\u2500 adapters/\n\u2502   \u2502   \u251c\u2500\u2500 handlers/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 auth_handler.go\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 user_handler.go\n\u2502   \u2502   \u251c\u2500\u2500 middleware/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 auth_middleware.go\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 error_handler.go\n\u2502   \u2502   \u2514\u2500\u2500 repository/\n\u2502   \u2502       \u2514\u2500\u2500 user_repository.go\n\u2502   \u251c\u2500\u2500 infrastructure/\n\u2502   \u2502   \u251c\u2500\u2500 database/\n\u2502   \u2502   \u2514\u2500\u2500 server/\n\u2502   \u2514\u2500\u2500 interfaces/                   # Ports (interfaces)\n\u2502       \u2514\u2500\u2500 user_repository.go\n\u251c\u2500\u2500 pkg/\n\u2502   \u251c\u2500\u2500 auth/                         # JWT utilities\n\u2502   \u251c\u2500\u2500 config/                       # Configuration\n\u2502   \u2514\u2500\u2500 logger/                       # Zerolog logger\n\u251c\u2500\u2500 docs/\n\u2502   \u251c\u2500\u2500 README.md\n\u2502   \u2514\u2500\u2500 quick-start.md\n\u251c\u2500\u2500 .env                              # Configuration (auto-copi\u00e9)\n\u251c\u2500\u2500 .env.example\n\u251c\u2500\u2500 Dockerfile\n\u251c\u2500\u2500 Makefile\n\u251c\u2500\u2500 go.mod\n\u2514\u2500\u2500 README.md\n</code></pre></p> <p>\u2705 Checkpoint 1: Le projet est g\u00e9n\u00e9r\u00e9 avec succ\u00e8s.</p>"},{"location":"tutorial-exemple-complet/#etape-3-configuration-initiale","title":"\u00c9tape 3: Configuration initiale","text":""},{"location":"tutorial-exemple-complet/#31-installer-les-dependances","title":"3.1 Installer les d\u00e9pendances","text":"<pre><code>cd blog-api\ngo mod tidy\n</code></pre> <p>Cette commande t\u00e9l\u00e9charge toutes les d\u00e9pendances (Fiber, GORM, fx, etc.).</p>"},{"location":"tutorial-exemple-complet/#32-configurer-postgresql","title":"3.2 Configurer PostgreSQL","text":"<p>Vous avez 2 options:</p>"},{"location":"tutorial-exemple-complet/#option-a-docker-recommande","title":"Option A: Docker (recommand\u00e9)","text":"<pre><code>docker run -d \\\n  --name blog-postgres \\\n  -e POSTGRES_DB=blog_api \\\n  -e POSTGRES_PASSWORD=postgres \\\n  -p 5432:5432 \\\n  postgres:16-alpine\n</code></pre>"},{"location":"tutorial-exemple-complet/#option-b-postgresql-local","title":"Option B: PostgreSQL local","text":"<p>Si PostgreSQL est install\u00e9 localement:</p> <pre><code>createdb blog_api\n</code></pre>"},{"location":"tutorial-exemple-complet/#33-configurer-les-variables-denvironnement","title":"3.3 Configurer les variables d'environnement","text":"<p>G\u00e9n\u00e9rer un secret JWT s\u00e9curis\u00e9:</p> <pre><code>JWT_SECRET=$(openssl rand -base64 32)\necho \"JWT_SECRET g\u00e9n\u00e9r\u00e9: $JWT_SECRET\"\n</code></pre> <p>\u00c9diter le fichier <code>.env</code>:</p> <pre><code>nano .env\n</code></pre> <p>Contenu du <code>.env</code>:</p> <pre><code># Application\nAPP_NAME=blog-api\nAPP_ENV=development\nAPP_PORT=8080\n\n# Database\nDB_HOST=localhost\nDB_PORT=5432\nDB_USER=postgres\nDB_PASSWORD=postgres\nDB_NAME=blog_api\nDB_SSLMODE=disable\n\n# JWT\nJWT_SECRET=&lt;coller_le_secret_g\u00e9n\u00e9r\u00e9_ici&gt;\nJWT_EXPIRY=15m\nREFRESH_TOKEN_EXPIRY=168h\n</code></pre> <p>Important: Remplacez <code>&lt;coller_le_secret_g\u00e9n\u00e9r\u00e9_ici&gt;</code> par le JWT_SECRET g\u00e9n\u00e9r\u00e9.</p>"},{"location":"tutorial-exemple-complet/#etape-4-tester-le-projet-de-base","title":"\u00c9tape 4: Tester le projet de base","text":""},{"location":"tutorial-exemple-complet/#41-lancer-lapplication","title":"4.1 Lancer l'application","text":"<pre><code>make run\n</code></pre> <p>Vous devriez voir:</p> <pre><code>2024/01/10 10:00:00 INF Starting blog-api server on :8080\n</code></pre>"},{"location":"tutorial-exemple-complet/#42-tester-le-health-check","title":"4.2 Tester le health check","text":"<p>Dans un autre terminal:</p> <pre><code>curl http://localhost:8080/health\n</code></pre> <p>R\u00e9ponse attendue: <pre><code>{\"status\":\"ok\"}\n</code></pre></p>"},{"location":"tutorial-exemple-complet/#43-tester-lauthentification-par-defaut","title":"4.3 Tester l'authentification par d\u00e9faut","text":""},{"location":"tutorial-exemple-complet/#creer-un-utilisateur","title":"Cr\u00e9er un utilisateur","text":"<pre><code>curl -X POST http://localhost:8080/api/v1/auth/register \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"email\": \"admin@blog.com\",\n    \"password\": \"admin123\"\n  }'\n</code></pre> <p>R\u00e9ponse: <pre><code>{\n  \"access_token\": \"eyJhbGci...\",\n  \"refresh_token\": \"eyJhbGci...\",\n  \"user\": {\n    \"id\": 1,\n    \"email\": \"admin@blog.com\",\n    \"created_at\": \"2024-01-10T10:05:00Z\"\n  }\n}\n</code></pre></p>"},{"location":"tutorial-exemple-complet/#se-connecter","title":"Se connecter","text":"<pre><code>curl -X POST http://localhost:8080/api/v1/auth/login \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"email\": \"admin@blog.com\",\n    \"password\": \"admin123\"\n  }'\n</code></pre> <p>M\u00eame r\u00e9ponse avec access_token et refresh_token.</p>"},{"location":"tutorial-exemple-complet/#tester-une-route-protegee","title":"Tester une route prot\u00e9g\u00e9e","text":"<pre><code># Remplacez &lt;ACCESS_TOKEN&gt; par le token re\u00e7u\ncurl -X GET http://localhost:8080/api/v1/users \\\n  -H \"Authorization: Bearer &lt;ACCESS_TOKEN&gt;\"\n</code></pre> <p>R\u00e9ponse: <pre><code>[\n  {\n    \"id\": 1,\n    \"email\": \"admin@blog.com\",\n    \"created_at\": \"2024-01-10T10:05:00Z\"\n  }\n]\n</code></pre></p> <p>\u2705 Checkpoint 2: Le projet de base fonctionne parfaitement avec User et Auth.</p>"},{"location":"tutorial-exemple-complet/#etape-5-ajouter-le-domaine-post-article","title":"\u00c9tape 5: Ajouter le domaine Post (Article)","text":"<p>Nous allons maintenant ajouter notre premi\u00e8re fonctionnalit\u00e9: les articles de blog.</p>"},{"location":"tutorial-exemple-complet/#51-creer-lentite-post","title":"5.1 Cr\u00e9er l'entit\u00e9 Post","text":"<p>Cr\u00e9er le fichier <code>internal/models/post.go</code>:</p> <pre><code>package models\n\nimport (\n    \"strings\"\n    \"time\"\n\n    \"gorm.io/gorm\"\n)\n\n// Post repr\u00e9sente un article de blog\ntype Post struct {\n    ID        uint           `gorm:\"primarykey\" json:\"id\"`\n    CreatedAt time.Time      `json:\"created_at\"`\n    UpdatedAt time.Time      `json:\"updated_at\"`\n    DeletedAt gorm.DeletedAt `gorm:\"index\" json:\"-\"`\n\n    // Contenu\n    Title   string `gorm:\"not null;size:255\" json:\"title\" validate:\"required,max=255\"`\n    Slug    string `gorm:\"uniqueIndex;not null;size:255\" json:\"slug\"`\n    Content string `gorm:\"type:text;not null\" json:\"content\" validate:\"required\"`\n\n    // M\u00e9tadonn\u00e9es\n    Tags      string `gorm:\"size:500\" json:\"tags\"`\n    Published bool   `gorm:\"default:false\" json:\"published\"`\n\n    // Relations\n    AuthorID uint `gorm:\"not null\" json:\"author_id\"`\n}\n\n// BeforeCreate g\u00e9n\u00e8re automatiquement un slug unique avant l'insertion\nfunc (p *Post) BeforeCreate(tx *gorm.DB) error {\n    if p.Slug == \"\" {\n        p.Slug = slugify(p.Title)\n    }\n    return nil\n}\n\n// slugify convertit un titre en slug URL-friendly\n// Exemple: \"Mon Super Article!\" -&gt; \"mon-super-article\"\nfunc slugify(title string) string {\n    slug := strings.ToLower(title)\n    slug = strings.ReplaceAll(slug, \" \", \"-\")\n\n    // Supprimer les caract\u00e8res sp\u00e9ciaux\n    replacer := strings.NewReplacer(\n        \"!\", \"\", \"?\", \"\", \".\", \"\", \",\", \"\",\n        \"'\", \"\", \"\\\"\", \"\", \":\", \"\", \";\", \"\",\n        \"(\", \"\", \")\", \"\", \"[\", \"\", \"]\", \"\",\n    )\n    slug = replacer.Replace(slug)\n\n    // Supprimer les tirets multiples\n    for strings.Contains(slug, \"--\") {\n        slug = strings.ReplaceAll(slug, \"--\", \"-\")\n    }\n\n    // Supprimer les tirets en d\u00e9but/fin\n    slug = strings.Trim(slug, \"-\")\n\n    return slug\n}\n</code></pre> <p>Explications:</p> <ul> <li>struct Post: D\u00e9finit la structure d'un article</li> <li><code>ID</code>, <code>CreatedAt</code>, <code>UpdatedAt</code>, <code>DeletedAt</code>: Champs GORM standard</li> <li><code>Title</code>, <code>Content</code>: Contenu de l'article</li> <li><code>Slug</code>: URL-friendly version du titre (ex: \"mon-article\")</li> <li><code>Tags</code>: Tags s\u00e9par\u00e9s par virgule</li> <li><code>Published</code>: Boolean pour publier/d\u00e9publier</li> <li> <p><code>AuthorID</code>: R\u00e9f\u00e9rence \u00e0 l'utilisateur (User.ID)</p> </li> <li> <p>BeforeCreate: Hook GORM qui s'ex\u00e9cute avant l'insertion en DB</p> </li> <li> <p>G\u00e9n\u00e8re automatiquement le slug depuis le titre</p> </li> <li> <p>slugify: Fonction helper pour cr\u00e9er un slug</p> </li> <li>\"Mon Super Article!\" devient \"mon-super-article\"</li> </ul>"},{"location":"tutorial-exemple-complet/#etape-6-implementer-le-service-post","title":"\u00c9tape 6: Impl\u00e9menter le service Post","text":""},{"location":"tutorial-exemple-complet/#61-definir-linterface-postservice","title":"6.1 D\u00e9finir l'interface PostService","text":"<p>Cr\u00e9er <code>internal/interfaces/post_service.go</code>:</p> <pre><code>package interfaces\n\nimport (\n    \"context\"\n\n    \"blog-api/internal/models\"\n)\n\n// PostService d\u00e9finit les op\u00e9rations m\u00e9tier sur les articles\ntype PostService interface {\n    Create(ctx context.Context, authorID uint, title, content, tags string) (*models.Post, error)\n    GetByID(ctx context.Context, id uint) (*models.Post, error)\n    GetBySlug(ctx context.Context, slug string) (*models.Post, error)\n    List(ctx context.Context, limit, offset int) ([]*models.Post, int64, error)\n    ListByAuthor(ctx context.Context, authorID uint, limit, offset int) ([]*models.Post, int64, error)\n    Update(ctx context.Context, id uint, title, content, tags *string) (*models.Post, error)\n    Publish(ctx context.Context, id uint) error\n    Unpublish(ctx context.Context, id uint) error\n    Delete(ctx context.Context, id uint) error\n}\n</code></pre>"},{"location":"tutorial-exemple-complet/#62-definir-linterface-postrepository","title":"6.2 D\u00e9finir l'interface PostRepository","text":"<p>Cr\u00e9er <code>internal/interfaces/post_repository.go</code>:</p> <pre><code>package interfaces\n\nimport (\n    \"context\"\n\n    \"blog-api/internal/models\"\n)\n\n// PostRepository d\u00e9finit les op\u00e9rations de persistance pour les articles\ntype PostRepository interface {\n    Create(ctx context.Context, post *models.Post) error\n    FindByID(ctx context.Context, id uint) (*models.Post, error)\n    FindBySlug(ctx context.Context, slug string) (*models.Post, error)\n    FindAll(ctx context.Context, limit, offset int) ([]*models.Post, int64, error)\n    FindByAuthorID(ctx context.Context, authorID uint, limit, offset int) ([]*models.Post, int64, error)\n    Update(ctx context.Context, post *models.Post) error\n    Delete(ctx context.Context, id uint) error\n}\n</code></pre>"},{"location":"tutorial-exemple-complet/#63-implementer-le-service","title":"6.3 Impl\u00e9menter le service","text":"<p>Cr\u00e9er <code>internal/domain/post/service.go</code>:</p> <pre><code>package post\n\nimport (\n    \"context\"\n\n    \"blog-api/internal/domain\"\n    \"blog-api/internal/interfaces\"\n    \"github.com/rs/zerolog\"\n)\n\ntype service struct {\n    repo   interfaces.PostRepository\n    logger zerolog.Logger\n}\n\n// NewService cr\u00e9e une nouvelle instance du service Post\nfunc NewService(repo interfaces.PostRepository, logger zerolog.Logger) interfaces.PostService {\n    return &amp;service{\n        repo:   repo,\n        logger: logger,\n    }\n}\n\n// Create cr\u00e9e un nouvel article\nfunc (s *service) Create(ctx context.Context, authorID uint, title, content, tags string) (*Post, error) {\n    post := &amp;Post{\n        Title:     title,\n        Content:   content,\n        Tags:      tags,\n        AuthorID:  authorID,\n        Published: false,\n    }\n\n    if err := s.repo.Create(ctx, post); err != nil {\n        s.logger.Error().Err(err).Msg(\"Failed to create post\")\n        return nil, err\n    }\n\n    s.logger.Info().\n        Uint(\"post_id\", post.ID).\n        Uint(\"author_id\", authorID).\n        Str(\"title\", title).\n        Msg(\"Post created successfully\")\n\n    return post, nil\n}\n\n// GetByID r\u00e9cup\u00e8re un article par son ID\nfunc (s *service) GetByID(ctx context.Context, id uint) (*Post, error) {\n    post, err := s.repo.FindByID(ctx, id)\n    if err != nil {\n        return nil, domain.NewNotFoundError(\"Post not found\", \"POST_NOT_FOUND\", err)\n    }\n    return post, nil\n}\n\n// GetBySlug r\u00e9cup\u00e8re un article par son slug\nfunc (s *service) GetBySlug(ctx context.Context, slug string) (*Post, error) {\n    post, err := s.repo.FindBySlug(ctx, slug)\n    if err != nil {\n        return nil, domain.NewNotFoundError(\"Post not found\", \"POST_NOT_FOUND\", err)\n    }\n    return post, nil\n}\n\n// List r\u00e9cup\u00e8re tous les articles avec pagination\nfunc (s *service) List(ctx context.Context, limit, offset int) ([]*Post, int64, error) {\n    return s.repo.FindAll(ctx, limit, offset)\n}\n\n// ListByAuthor r\u00e9cup\u00e8re les articles d'un auteur avec pagination\nfunc (s *service) ListByAuthor(ctx context.Context, authorID uint, limit, offset int) ([]*Post, int64, error) {\n    return s.repo.FindByAuthorID(ctx, authorID, limit, offset)\n}\n\n// Update met \u00e0 jour un article\nfunc (s *service) Update(ctx context.Context, id uint, title, content, tags *string) (*Post, error) {\n    post, err := s.repo.FindByID(ctx, id)\n    if err != nil {\n        return nil, domain.NewNotFoundError(\"Post not found\", \"POST_NOT_FOUND\", err)\n    }\n\n    // Mettre \u00e0 jour uniquement les champs fournis\n    if title != nil {\n        post.Title = *title\n        post.Slug = slugify(*title) // R\u00e9g\u00e9n\u00e9rer le slug\n    }\n    if content != nil {\n        post.Content = *content\n    }\n    if tags != nil {\n        post.Tags = *tags\n    }\n\n    if err := s.repo.Update(ctx, post); err != nil {\n        s.logger.Error().Err(err).Uint(\"post_id\", id).Msg(\"Failed to update post\")\n        return nil, err\n    }\n\n    s.logger.Info().Uint(\"post_id\", id).Msg(\"Post updated successfully\")\n    return post, nil\n}\n\n// Publish publie un article\nfunc (s *service) Publish(ctx context.Context, id uint) error {\n    post, err := s.repo.FindByID(ctx, id)\n    if err != nil {\n        return domain.NewNotFoundError(\"Post not found\", \"POST_NOT_FOUND\", err)\n    }\n\n    post.Published = true\n    if err := s.repo.Update(ctx, post); err != nil {\n        s.logger.Error().Err(err).Uint(\"post_id\", id).Msg(\"Failed to publish post\")\n        return err\n    }\n\n    s.logger.Info().Uint(\"post_id\", id).Msg(\"Post published successfully\")\n    return nil\n}\n\n// Unpublish d\u00e9publie un article\nfunc (s *service) Unpublish(ctx context.Context, id uint) error {\n    post, err := s.repo.FindByID(ctx, id)\n    if err != nil {\n        return domain.NewNotFoundError(\"Post not found\", \"POST_NOT_FOUND\", err)\n    }\n\n    post.Published = false\n    if err := s.repo.Update(ctx, post); err != nil {\n        s.logger.Error().Err(err).Uint(\"post_id\", id).Msg(\"Failed to unpublish post\")\n        return err\n    }\n\n    s.logger.Info().Uint(\"post_id\", id).Msg(\"Post unpublished successfully\")\n    return nil\n}\n\n// Delete supprime un article (soft delete)\nfunc (s *service) Delete(ctx context.Context, id uint) error {\n    if err := s.repo.Delete(ctx, id); err != nil {\n        s.logger.Error().Err(err).Uint(\"post_id\", id).Msg(\"Failed to delete post\")\n        return domain.NewNotFoundError(\"Post not found\", \"POST_NOT_FOUND\", err)\n    }\n\n    s.logger.Info().Uint(\"post_id\", id).Msg(\"Post deleted successfully\")\n    return nil\n}\n</code></pre> <p>Points cl\u00e9s:</p> <ul> <li>Dependency Injection: Le service re\u00e7oit le repository et le logger via le constructeur</li> <li>Error handling: Utilise les erreurs du domaine (<code>domain.NewNotFoundError</code>)</li> <li>Logging structur\u00e9: Log avec zerolog pour chaque op\u00e9ration</li> <li>Business logic: G\u00e8re la publication/d\u00e9publication, la g\u00e9n\u00e9ration de slug, etc.</li> </ul>"},{"location":"tutorial-exemple-complet/#etape-7-creer-le-repository-post","title":"\u00c9tape 7: Cr\u00e9er le repository Post","text":"<p>Cr\u00e9er <code>internal/adapters/repository/post_repository.go</code>:</p> <pre><code>package repository\n\nimport (\n    \"context\"\n\n    \"blog-api/internal/models\"\n    \"blog-api/internal/interfaces\"\n    \"gorm.io/gorm\"\n)\n\ntype postRepository struct {\n    db *gorm.DB\n}\n\n// NewPostRepository cr\u00e9e une nouvelle instance du repository Post\nfunc NewPostRepository(db *gorm.DB) interfaces.PostRepository {\n    return &amp;postRepository{db: db}\n}\n\n// Create ins\u00e8re un nouvel article dans la base de donn\u00e9es\nfunc (r *postRepository) Create(ctx context.Context, post *models.Post) error {\n    return r.db.WithContext(ctx).Create(post).Error\n}\n\n// FindByID r\u00e9cup\u00e8re un article par son ID\nfunc (r *postRepository) FindByID(ctx context.Context, id uint) (*models.Post, error) {\n    var p post.Post\n    err := r.db.WithContext(ctx).First(&amp;p, id).Error\n    if err != nil {\n        return nil, err\n    }\n    return &amp;p, nil\n}\n\n// FindBySlug r\u00e9cup\u00e8re un article par son slug\nfunc (r *postRepository) FindBySlug(ctx context.Context, slug string) (*models.Post, error) {\n    var p post.Post\n    err := r.db.WithContext(ctx).Where(\"slug = ?\", slug).First(&amp;p).Error\n    if err != nil {\n        return nil, err\n    }\n    return &amp;p, nil\n}\n\n// FindAll r\u00e9cup\u00e8re tous les articles avec pagination\n// Retourne les posts + le total count\nfunc (r *postRepository) FindAll(ctx context.Context, limit, offset int) ([]*models.Post, int64, error) {\n    var posts []*models.Post\n    var total int64\n\n    // Count total\n    if err := r.db.WithContext(ctx).Model(&amp;models.Post{}).Count(&amp;total).Error; err != nil {\n        return nil, 0, err\n    }\n\n    // R\u00e9cup\u00e9rer les posts\n    err := r.db.WithContext(ctx).\n        Limit(limit).\n        Offset(offset).\n        Order(\"created_at DESC\").\n        Find(&amp;posts).Error\n\n    return posts, total, err\n}\n\n// FindByAuthorID r\u00e9cup\u00e8re les articles d'un auteur avec pagination\nfunc (r *postRepository) FindByAuthorID(ctx context.Context, authorID uint, limit, offset int) ([]*models.Post, int64, error) {\n    var posts []*models.Post\n    var total int64\n\n    query := r.db.WithContext(ctx).Where(\"author_id = ?\", authorID)\n\n    // Count total\n    if err := query.Model(&amp;models.Post{}).Count(&amp;total).Error; err != nil {\n        return nil, 0, err\n    }\n\n    // R\u00e9cup\u00e9rer les posts\n    err := query.\n        Limit(limit).\n        Offset(offset).\n        Order(\"created_at DESC\").\n        Find(&amp;posts).Error\n\n    return posts, total, err\n}\n\n// Update met \u00e0 jour un article\nfunc (r *postRepository) Update(ctx context.Context, post *models.Post) error {\n    return r.db.WithContext(ctx).Save(post).Error\n}\n\n// Delete supprime un article (soft delete avec GORM)\nfunc (r *postRepository) Delete(ctx context.Context, id uint) error {\n    return r.db.WithContext(ctx).Delete(&amp;models.Post{}, id).Error\n}\n</code></pre> <p>Points cl\u00e9s:</p> <ul> <li>GORM: Utilise GORM pour interagir avec PostgreSQL</li> <li>Context: Chaque m\u00e9thode accepte un context pour les timeouts/annulations</li> <li>Pagination: FindAll et FindByAuthorID retournent total count + posts</li> <li>Soft Delete: GORM g\u00e8re automatiquement le soft delete via DeletedAt</li> </ul>"},{"location":"tutorial-exemple-complet/#etape-8-creer-le-handler-http","title":"\u00c9tape 8: Cr\u00e9er le handler HTTP","text":""},{"location":"tutorial-exemple-complet/#81-creer-le-handler","title":"8.1 Cr\u00e9er le handler","text":"<p>Cr\u00e9er <code>internal/adapters/handlers/post_handler.go</code>:</p> <pre><code>package handlers\n\nimport (\n    \"strconv\"\n\n    \"blog-api/internal/interfaces\"\n    \"blog-api/pkg/auth\"\n    \"github.com/gofiber/fiber/v2\"\n    \"github.com/rs/zerolog\"\n)\n\ntype PostHandler struct {\n    postService interfaces.PostService\n    logger      zerolog.Logger\n}\n\nfunc NewPostHandler(postService interfaces.PostService, logger zerolog.Logger) *PostHandler {\n    return &amp;PostHandler{\n        postService: postService,\n        logger:      logger,\n    }\n}\n\n// CreatePostRequest repr\u00e9sente la requ\u00eate de cr\u00e9ation d'article\ntype CreatePostRequest struct {\n    Title   string `json:\"title\" validate:\"required,max=255\"`\n    Content string `json:\"content\" validate:\"required\"`\n    Tags    string `json:\"tags\"`\n}\n\n// UpdatePostRequest repr\u00e9sente la requ\u00eate de mise \u00e0 jour d'article\ntype UpdatePostRequest struct {\n    Title   *string `json:\"title,omitempty\" validate:\"omitempty,max=255\"`\n    Content *string `json:\"content,omitempty\"`\n    Tags    *string `json:\"tags,omitempty\"`\n}\n\n// Create cr\u00e9e un nouvel article\n// POST /api/v1/posts\nfunc (h *PostHandler) Create(c *fiber.Ctx) error {\n    var req CreatePostRequest\n    if err := c.BodyParser(&amp;req); err != nil {\n        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{\n            \"error\": \"Invalid request body\",\n        })\n    }\n\n    // Validation\n    if err := validate.Struct(req); err != nil {\n        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{\n            \"error\": err.Error(),\n        })\n    }\n\n    // R\u00e9cup\u00e9rer l'utilisateur authentifi\u00e9 depuis le context\n    userID := c.Locals(\"userID\").(uint)\n\n    // Cr\u00e9er le post\n    post, err := h.postService.Create(c.Context(), userID, req.Title, req.Content, req.Tags)\n    if err != nil {\n        h.logger.Error().Err(err).Msg(\"Failed to create post\")\n        return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{\n            \"error\": \"Failed to create post\",\n        })\n    }\n\n    return c.Status(fiber.StatusCreated).JSON(post)\n}\n\n// Get r\u00e9cup\u00e8re un article par ID ou slug\n// GET /api/v1/posts/:idOrSlug\nfunc (h *PostHandler) Get(c *fiber.Ctx) error {\n    idOrSlug := c.Params(\"idOrSlug\")\n\n    // Essayer de parser comme ID\n    if id, err := strconv.ParseUint(idOrSlug, 10, 32); err == nil {\n        post, err := h.postService.GetByID(c.Context(), uint(id))\n        if err != nil {\n            return c.Status(fiber.StatusNotFound).JSON(fiber.Map{\n                \"error\": \"Post not found\",\n            })\n        }\n        return c.JSON(post)\n    }\n\n    // Sinon, chercher par slug\n    post, err := h.postService.GetBySlug(c.Context(), idOrSlug)\n    if err != nil {\n        return c.Status(fiber.StatusNotFound).JSON(fiber.Map{\n            \"error\": \"Post not found\",\n        })\n    }\n\n    return c.JSON(post)\n}\n\n// List r\u00e9cup\u00e8re tous les articles avec pagination\n// GET /api/v1/posts?limit=10&amp;offset=0\nfunc (h *PostHandler) List(c *fiber.Ctx) error {\n    // Param\u00e8tres de pagination\n    limit := c.QueryInt(\"limit\", 10)\n    offset := c.QueryInt(\"offset\", 0)\n\n    // Limiter le nombre max de r\u00e9sultats\n    if limit &gt; 100 {\n        limit = 100\n    }\n\n    posts, total, err := h.postService.List(c.Context(), limit, offset)\n    if err != nil {\n        h.logger.Error().Err(err).Msg(\"Failed to list posts\")\n        return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{\n            \"error\": \"Failed to list posts\",\n        })\n    }\n\n    return c.JSON(fiber.Map{\n        \"data\":   posts,\n        \"total\":  total,\n        \"limit\":  limit,\n        \"offset\": offset,\n    })\n}\n\n// ListByAuthor r\u00e9cup\u00e8re les articles d'un auteur\n// GET /api/v1/posts/author/:authorID?limit=10&amp;offset=0\nfunc (h *PostHandler) ListByAuthor(c *fiber.Ctx) error {\n    authorID, err := strconv.ParseUint(c.Params(\"authorID\"), 10, 32)\n    if err != nil {\n        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{\n            \"error\": \"Invalid author ID\",\n        })\n    }\n\n    limit := c.QueryInt(\"limit\", 10)\n    offset := c.QueryInt(\"offset\", 0)\n\n    if limit &gt; 100 {\n        limit = 100\n    }\n\n    posts, total, err := h.postService.ListByAuthor(c.Context(), uint(authorID), limit, offset)\n    if err != nil {\n        h.logger.Error().Err(err).Msg(\"Failed to list posts by author\")\n        return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{\n            \"error\": \"Failed to list posts\",\n        })\n    }\n\n    return c.JSON(fiber.Map{\n        \"data\":   posts,\n        \"total\":  total,\n        \"limit\":  limit,\n        \"offset\": offset,\n    })\n}\n\n// Update met \u00e0 jour un article\n// PUT /api/v1/posts/:id\nfunc (h *PostHandler) Update(c *fiber.Ctx) error {\n    id, err := strconv.ParseUint(c.Params(\"id\"), 10, 32)\n    if err != nil {\n        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{\n            \"error\": \"Invalid post ID\",\n        })\n    }\n\n    var req UpdatePostRequest\n    if err := c.BodyParser(&amp;req); err != nil {\n        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{\n            \"error\": \"Invalid request body\",\n        })\n    }\n\n    // Validation\n    if err := validate.Struct(req); err != nil {\n        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{\n            \"error\": err.Error(),\n        })\n    }\n\n    // Mettre \u00e0 jour\n    post, err := h.postService.Update(c.Context(), uint(id), req.Title, req.Content, req.Tags)\n    if err != nil {\n        h.logger.Error().Err(err).Msg(\"Failed to update post\")\n        return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{\n            \"error\": \"Failed to update post\",\n        })\n    }\n\n    return c.JSON(post)\n}\n\n// Publish publie un article\n// POST /api/v1/posts/:id/publish\nfunc (h *PostHandler) Publish(c *fiber.Ctx) error {\n    id, err := strconv.ParseUint(c.Params(\"id\"), 10, 32)\n    if err != nil {\n        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{\n            \"error\": \"Invalid post ID\",\n        })\n    }\n\n    if err := h.postService.Publish(c.Context(), uint(id)); err != nil {\n        h.logger.Error().Err(err).Msg(\"Failed to publish post\")\n        return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{\n            \"error\": \"Failed to publish post\",\n        })\n    }\n\n    return c.JSON(fiber.Map{\n        \"message\": \"Post published successfully\",\n    })\n}\n\n// Unpublish d\u00e9publie un article\n// POST /api/v1/posts/:id/unpublish\nfunc (h *PostHandler) Unpublish(c *fiber.Ctx) error {\n    id, err := strconv.ParseUint(c.Params(\"id\"), 10, 32)\n    if err != nil {\n        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{\n            \"error\": \"Invalid post ID\",\n        })\n    }\n\n    if err := h.postService.Unpublish(c.Context(), uint(id)); err != nil {\n        h.logger.Error().Err(err).Msg(\"Failed to unpublish post\")\n        return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{\n            \"error\": \"Failed to unpublish post\",\n        })\n    }\n\n    return c.JSON(fiber.Map{\n        \"message\": \"Post unpublished successfully\",\n    })\n}\n\n// Delete supprime un article\n// DELETE /api/v1/posts/:id\nfunc (h *PostHandler) Delete(c *fiber.Ctx) error {\n    id, err := strconv.ParseUint(c.Params(\"id\"), 10, 32)\n    if err != nil {\n        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{\n            \"error\": \"Invalid post ID\",\n        })\n    }\n\n    if err := h.postService.Delete(c.Context(), uint(id)); err != nil {\n        h.logger.Error().Err(err).Msg(\"Failed to delete post\")\n        return c.Status(fiber.StatusNotFound).JSON(fiber.Map{\n            \"error\": \"Post not found\",\n        })\n    }\n\n    return c.Status(fiber.StatusNoContent).Send(nil)\n}\n</code></pre> <p>Points cl\u00e9s:</p> <ul> <li>Validation: Utilise validator pour valider les requ\u00eates</li> <li>Authentication: R\u00e9cup\u00e8re userID depuis le context (middleware auth)</li> <li>Error handling: Retourne des codes HTTP appropri\u00e9s</li> <li>Pagination: Support limit/offset pour les listes</li> </ul>"},{"location":"tutorial-exemple-complet/#etape-9-enregistrer-les-routes-et-le-module","title":"\u00c9tape 9: Enregistrer les routes et le module","text":""},{"location":"tutorial-exemple-complet/#91-creer-le-module-fx","title":"9.1 Cr\u00e9er le module fx","text":"<p>Cr\u00e9er <code>internal/domain/post/module.go</code>:</p> <pre><code>package post\n\nimport (\n    \"blog-api/internal/adapters/handlers\"\n    \"blog-api/internal/adapters/repository\"\n    \"go.uber.org/fx\"\n)\n\n// Module provides all Post domain dependencies\nvar Module = fx.Module(\"post\",\n    fx.Provide(\n        repository.NewPostRepository,\n        NewService,\n        handlers.NewPostHandler,\n    ),\n)\n</code></pre>"},{"location":"tutorial-exemple-complet/#92-enregistrer-les-routes","title":"9.2 Enregistrer les routes","text":"<p>Modifier <code>internal/infrastructure/server/routes.go</code>:</p> <p>Ajouter apr\u00e8s les routes User existantes:</p> <pre><code>// Post routes (protected)\npostRoutes := v1.Group(\"/posts\")\npostRoutes.Get(\"/\", postHandler.List)                    // Liste tous les posts\npostRoutes.Get(\"/:idOrSlug\", postHandler.Get)            // R\u00e9cup\u00e9rer par ID ou slug\npostRoutes.Get(\"/author/:authorID\", postHandler.ListByAuthor) // Posts par auteur\n\npostRoutes.Use(authMiddleware.RequireAuth())             // Routes prot\u00e9g\u00e9es ci-dessous\npostRoutes.Post(\"/\", postHandler.Create)                 // Cr\u00e9er un post\npostRoutes.Put(\"/:id\", postHandler.Update)               // Mettre \u00e0 jour\npostRoutes.Post(\"/:id/publish\", postHandler.Publish)     // Publier\npostRoutes.Post(\"/:id/unpublish\", postHandler.Unpublish) // D\u00e9publier\npostRoutes.Delete(\"/:id\", postHandler.Delete)            // Supprimer\n</code></pre> <p>Le fichier complet <code>routes.go</code> devient:</p> <pre><code>package server\n\nimport (\n    \"blog-api/internal/adapters/handlers\"\n    \"blog-api/internal/adapters/middleware\"\n    \"github.com/gofiber/fiber/v2\"\n)\n\ntype RouteParams struct {\n    App            *fiber.App\n    AuthHandler    *handlers.AuthHandler\n    UserHandler    *handlers.UserHandler\n    PostHandler    *handlers.PostHandler  // Ajout\u00e9\n    AuthMiddleware *middleware.AuthMiddleware\n}\n\nfunc RegisterRoutes(params RouteParams) {\n    app := params.App\n    authHandler := params.AuthHandler\n    userHandler := params.UserHandler\n    postHandler := params.PostHandler  // Ajout\u00e9\n    authMiddleware := params.AuthMiddleware\n\n    // Health check (public)\n    app.Get(\"/health\", func(c *fiber.Ctx) error {\n        return c.JSON(fiber.Map{\"status\": \"ok\"})\n    })\n\n    // API v1\n    v1 := app.Group(\"/api/v1\")\n\n    // Auth routes (public)\n    auth := v1.Group(\"/auth\")\n    auth.Post(\"/register\", authHandler.Register)\n    auth.Post(\"/login\", authHandler.Login)\n    auth.Post(\"/refresh\", authHandler.RefreshToken)\n\n    // User routes (protected)\n    users := v1.Group(\"/users\")\n    users.Use(authMiddleware.RequireAuth())\n    users.Get(\"/\", userHandler.List)\n    users.Get(\"/:id\", userHandler.GetByID)\n    users.Put(\"/:id\", userHandler.Update)\n    users.Delete(\"/:id\", userHandler.Delete)\n\n    // Post routes\n    postRoutes := v1.Group(\"/posts\")\n    postRoutes.Get(\"/\", postHandler.List)\n    postRoutes.Get(\"/:idOrSlug\", postHandler.Get)\n    postRoutes.Get(\"/author/:authorID\", postHandler.ListByAuthor)\n\n    postRoutes.Use(authMiddleware.RequireAuth())\n    postRoutes.Post(\"/\", postHandler.Create)\n    postRoutes.Put(\"/:id\", postHandler.Update)\n    postRoutes.Post(\"/:id/publish\", postHandler.Publish)\n    postRoutes.Post(\"/:id/unpublish\", postHandler.Unpublish)\n    postRoutes.Delete(\"/:id\", postHandler.Delete)\n}\n</code></pre>"},{"location":"tutorial-exemple-complet/#93-ajouter-le-module-au-main","title":"9.3 Ajouter le module au main","text":"<p>Modifier <code>cmd/main.go</code>:</p> <pre><code>package main\n\nimport (\n    \"context\"\n\n    \"blog-api/internal/models\"  // Ajout\u00e9\n    \"blog-api/internal/domain/user\"\n    \"blog-api/internal/infrastructure/database\"\n    \"blog-api/internal/infrastructure/server\"\n    \"blog-api/pkg/config\"\n    \"blog-api/pkg/logger\"\n    \"go.uber.org/fx\"\n)\n\nfunc main() {\n    fx.New(\n        // Configuration\n        fx.Provide(\n            config.Load,\n            logger.New,\n        ),\n\n        // Infrastructure\n        database.Module,\n        server.Module,\n\n        // Domains\n        user.Module,\n        post.Module,  // Ajout\u00e9\n\n        fx.Invoke(func(lc fx.Lifecycle, srv *server.Server) {\n            lc.Append(fx.Hook{\n                OnStart: func(ctx context.Context) error {\n                    go srv.Start()\n                    return nil\n                },\n                OnStop: func(ctx context.Context) error {\n                    return srv.Shutdown()\n                },\n            })\n        }),\n    ).Run()\n}\n</code></pre>"},{"location":"tutorial-exemple-complet/#94-migration-de-la-base-de-donnees","title":"9.4 Migration de la base de donn\u00e9es","text":"<p>Modifier <code>internal/infrastructure/database/migrations.go</code>:</p> <p>Ajouter l'entit\u00e9 Post aux migrations:</p> <pre><code>package database\n\nimport (\n    \"blog-api/internal/models\"  // Ajout\u00e9\n    \"blog-api/internal/domain/user\"\n    \"github.com/rs/zerolog\"\n    \"gorm.io/gorm\"\n)\n\n// RunMigrations ex\u00e9cute les migrations automatiques pour toutes les entit\u00e9s\nfunc RunMigrations(db *gorm.DB, logger zerolog.Logger) error {\n    logger.Info().Msg(\"Running database migrations...\")\n\n    if err := db.AutoMigrate(\n        &amp;models.User{},\n        &amp;models.RefreshToken{},\n        &amp;models.Post{},  // Ajout\u00e9\n    ); err != nil {\n        logger.Error().Err(err).Msg(\"Failed to run migrations\")\n        return err\n    }\n\n    logger.Info().Msg(\"Database migrations completed successfully\")\n    return nil\n}\n</code></pre>"},{"location":"tutorial-exemple-complet/#etape-10-tester-lapi-posts","title":"\u00c9tape 10: Tester l'API Posts","text":""},{"location":"tutorial-exemple-complet/#101-relancer-lapplication","title":"10.1 Relancer l'application","text":"<pre><code># Arr\u00eater l'app (Ctrl+C)\n# Relancer\nmake run\n</code></pre> <p>Les migrations vont cr\u00e9er la table <code>posts</code> automatiquement.</p>"},{"location":"tutorial-exemple-complet/#102-creer-un-article","title":"10.2 Cr\u00e9er un article","text":"<p>R\u00e9cup\u00e9rez d'abord un access token (voir \u00c9tape 4.3).</p> <pre><code># Remplacez &lt;ACCESS_TOKEN&gt; par votre token\ncurl -X POST http://localhost:8080/api/v1/posts \\\n  -H \"Authorization: Bearer &lt;ACCESS_TOKEN&gt;\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"title\": \"Mon Premier Article\",\n    \"content\": \"Ceci est le contenu de mon premier article de blog!\",\n    \"tags\": \"golang,tutorial,blog\"\n  }'\n</code></pre> <p>R\u00e9ponse: <pre><code>{\n  \"id\": 1,\n  \"created_at\": \"2024-01-10T11:00:00Z\",\n  \"updated_at\": \"2024-01-10T11:00:00Z\",\n  \"title\": \"Mon Premier Article\",\n  \"slug\": \"mon-premier-article\",\n  \"content\": \"Ceci est le contenu de mon premier article de blog!\",\n  \"tags\": \"golang,tutorial,blog\",\n  \"published\": false,\n  \"author_id\": 1\n}\n</code></pre></p> <p>Notez que le slug a \u00e9t\u00e9 g\u00e9n\u00e9r\u00e9 automatiquement!</p>"},{"location":"tutorial-exemple-complet/#103-lister-les-articles","title":"10.3 Lister les articles","text":"<pre><code>curl http://localhost:8080/api/v1/posts\n</code></pre> <p>R\u00e9ponse: <pre><code>{\n  \"data\": [\n    {\n      \"id\": 1,\n      \"created_at\": \"2024-01-10T11:00:00Z\",\n      \"updated_at\": \"2024-01-10T11:00:00Z\",\n      \"title\": \"Mon Premier Article\",\n      \"slug\": \"mon-premier-article\",\n      \"content\": \"Ceci est le contenu de mon premier article de blog!\",\n      \"tags\": \"golang,tutorial,blog\",\n      \"published\": false,\n      \"author_id\": 1\n    }\n  ],\n  \"total\": 1,\n  \"limit\": 10,\n  \"offset\": 0\n}\n</code></pre></p>"},{"location":"tutorial-exemple-complet/#104-recuperer-un-article-par-slug","title":"10.4 R\u00e9cup\u00e9rer un article par slug","text":"<pre><code>curl http://localhost:8080/api/v1/posts/mon-premier-article\n</code></pre>"},{"location":"tutorial-exemple-complet/#105-publier-larticle","title":"10.5 Publier l'article","text":"<pre><code>curl -X POST http://localhost:8080/api/v1/posts/1/publish \\\n  -H \"Authorization: Bearer &lt;ACCESS_TOKEN&gt;\"\n</code></pre> <p>R\u00e9ponse: <pre><code>{\n  \"message\": \"Post published successfully\"\n}\n</code></pre></p>"},{"location":"tutorial-exemple-complet/#106-mettre-a-jour-larticle","title":"10.6 Mettre \u00e0 jour l'article","text":"<pre><code>curl -X PUT http://localhost:8080/api/v1/posts/1 \\\n  -H \"Authorization: Bearer &lt;ACCESS_TOKEN&gt;\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"title\": \"Mon Premier Article (\u00c9dit\u00e9)\",\n    \"content\": \"Contenu mis \u00e0 jour avec plus d\\'informations!\"\n  }'\n</code></pre>"},{"location":"tutorial-exemple-complet/#107-supprimer-larticle","title":"10.7 Supprimer l'article","text":"<pre><code>curl -X DELETE http://localhost:8080/api/v1/posts/1 \\\n  -H \"Authorization: Bearer &lt;ACCESS_TOKEN&gt;\"\n</code></pre> <p>Code retourn\u00e9: 204 No Content</p> <p>\u2705 Checkpoint 3: L'API Posts fonctionne compl\u00e8tement!</p>"},{"location":"tutorial-exemple-complet/#etape-11-ajouter-le-domaine-comment","title":"\u00c9tape 11: Ajouter le domaine Comment","text":"<p>Maintenant, ajoutons les commentaires sur les articles.</p>"},{"location":"tutorial-exemple-complet/#111-creer-lentite-comment","title":"11.1 Cr\u00e9er l'entit\u00e9 Comment","text":"<pre><code>mkdir -p internal/domain/comment\n</code></pre> <p>Cr\u00e9er <code>internal/models/comment.go</code>:</p> <pre><code>package models\n\nimport (\n    \"time\"\n\n    \"gorm.io/gorm\"\n)\n\n// Comment repr\u00e9sente un commentaire sur un article\ntype Comment struct {\n    ID        uint           `gorm:\"primarykey\" json:\"id\"`\n    CreatedAt time.Time      `json:\"created_at\"`\n    UpdatedAt time.Time      `json:\"updated_at\"`\n    DeletedAt gorm.DeletedAt `gorm:\"index\" json:\"-\"`\n\n    // Contenu\n    Content string `gorm:\"type:text;not null\" json:\"content\" validate:\"required\"`\n\n    // Relations\n    PostID   uint `gorm:\"not null;index\" json:\"post_id\"`\n    AuthorID uint `gorm:\"not null\" json:\"author_id\"`\n}\n</code></pre>"},{"location":"tutorial-exemple-complet/#112-creer-le-service-comment-simplifie","title":"11.2 Cr\u00e9er le service Comment (simplifi\u00e9)","text":"<p>Cr\u00e9er <code>internal/interfaces/comment_repository.go</code>:</p> <pre><code>package interfaces\n\nimport (\n    \"context\"\n\n    \"blog-api/internal/models\"\n)\n\ntype CommentRepository interface {\n    Create(ctx context.Context, comment *models.Comment) error\n    FindByPost(ctx context.Context, postID uint) ([]*models.Comment, error)\n    Delete(ctx context.Context, id uint) error\n}\n</code></pre> <p>Cr\u00e9er <code>internal/domain/comment/service.go</code>:</p> <pre><code>package comment\n\nimport (\n    \"context\"\n\n    \"blog-api/internal/models\"\n    \"blog-api/internal/interfaces\"\n    \"github.com/rs/zerolog\"\n)\n\ntype Service struct {\n    repo   interfaces.CommentRepository\n    logger zerolog.Logger\n}\n\nfunc NewService(repo interfaces.CommentRepository, logger zerolog.Logger) *Service {\n    return &amp;Service{repo: repo, logger: logger}\n}\n\nfunc (s *Service) Create(ctx context.Context, postID, authorID uint, content string) (*models.Comment, error) {\n    comment := &amp;models.Comment{\n        PostID:   postID,\n        AuthorID: authorID,\n        Content:  content,\n    }\n\n    if err := s.repo.Create(ctx, comment); err != nil {\n        s.logger.Error().Err(err).Msg(\"Failed to create comment\")\n        return nil, err\n    }\n\n    s.logger.Info().Uint(\"comment_id\", comment.ID).Uint(\"post_id\", postID).Msg(\"Comment created\")\n    return comment, nil\n}\n\nfunc (s *service) ListByPost(ctx context.Context, postID uint) ([]*Comment, error) {\n    return s.repo.FindByPostID(ctx, postID)\n}\n\nfunc (s *service) Delete(ctx context.Context, id uint) error {\n    if err := s.repo.Delete(ctx, id); err != nil {\n        s.logger.Error().Err(err).Uint(\"comment_id\", id).Msg(\"Failed to delete comment\")\n        return err\n    }\n\n    s.logger.Info().Uint(\"comment_id\", id).Msg(\"Comment deleted\")\n    return nil\n}\n</code></pre>"},{"location":"tutorial-exemple-complet/#113-creer-le-repository-et-handler","title":"11.3 Cr\u00e9er le repository et handler","text":"<p>Je vais vous laisser cr\u00e9er ces fichiers en suivant le m\u00eame pattern que Post:</p> <ul> <li><code>internal/interfaces/comment_repository.go</code></li> <li><code>internal/adapters/repository/comment_repository.go</code></li> <li><code>internal/adapters/handlers/comment_handler.go</code></li> <li><code>internal/domain/comment/module.go</code></li> </ul>"},{"location":"tutorial-exemple-complet/#114-ajouter-les-routes","title":"11.4 Ajouter les routes","text":"<p>Dans <code>routes.go</code>:</p> <pre><code>// Comment routes\ncommentRoutes := v1.Group(\"/comments\")\ncommentRoutes.Get(\"/post/:postID\", commentHandler.ListByPost)\n\ncommentRoutes.Use(authMiddleware.RequireAuth())\ncommentRoutes.Post(\"/\", commentHandler.Create)\ncommentRoutes.Delete(\"/:id\", commentHandler.Delete)\n</code></pre>"},{"location":"tutorial-exemple-complet/#115-mettre-a-jour-les-migrations","title":"11.5 Mettre \u00e0 jour les migrations","text":"<p>Dans <code>migrations.go</code>, ajouter <code>&amp;models.Comment{}</code>.</p> <p>\u2705 Checkpoint 4: Les commentaires sont fonctionnels!</p>"},{"location":"tutorial-exemple-complet/#etape-12-tests-unitaires","title":"\u00c9tape 12: Tests unitaires","text":""},{"location":"tutorial-exemple-complet/#121-tester-le-service-post","title":"12.1 Tester le service Post","text":"<p>Cr\u00e9er <code>internal/domain/post/service_test.go</code>:</p> <pre><code>package post_test\n\nimport (\n    \"context\"\n    \"testing\"\n\n    \"blog-api/internal/models\"\n    \"blog-api/internal/interfaces/mocks\"\n    \"blog-api/pkg/logger\"\n    \"github.com/stretchr/testify/assert\"\n    \"github.com/stretchr/testify/mock\"\n)\n\nfunc TestPostService_Create(t *testing.T) {\n    // Arrange\n    mockRepo := new(mocks.PostRepository)\n    log := logger.New(&amp;config.Config{AppEnv: \"test\"})\n    service := post.NewService(mockRepo, log)\n\n    mockRepo.On(\"Create\", mock.Anything, mock.AnythingOfType(\"*models.Post\")).\n        Return(nil)\n\n    // Act\n    result, err := service.Create(context.Background(), 1, \"Test Title\", \"Test Content\", \"tag1,tag2\")\n\n    // Assert\n    assert.NoError(t, err)\n    assert.NotNil(t, result)\n    assert.Equal(t, \"Test Title\", result.Title)\n    assert.Equal(t, \"test-title\", result.Slug)\n    mockRepo.AssertExpectations(t)\n}\n</code></pre>"},{"location":"tutorial-exemple-complet/#122-lancer-les-tests","title":"12.2 Lancer les tests","text":"<pre><code>make test\n</code></pre>"},{"location":"tutorial-exemple-complet/#etape-13-deploiement-docker","title":"\u00c9tape 13: D\u00e9ploiement Docker","text":""},{"location":"tutorial-exemple-complet/#131-build-limage-docker","title":"13.1 Build l'image Docker","text":"<pre><code>make docker-build\n</code></pre>"},{"location":"tutorial-exemple-complet/#132-lancer-avec-docker-compose","title":"13.2 Lancer avec docker-compose","text":"<p>Le fichier <code>docker-compose.yml</code> est d\u00e9j\u00e0 g\u00e9n\u00e9r\u00e9:</p> <pre><code>docker-compose up -d\n</code></pre> <p>Cela lance: - L'application sur le port 8080 - PostgreSQL sur le port 5432</p>"},{"location":"tutorial-exemple-complet/#133-verifier-le-deploiement","title":"13.3 V\u00e9rifier le d\u00e9ploiement","text":"<pre><code>curl http://localhost:8080/health\n</code></pre>"},{"location":"tutorial-exemple-complet/#conclusion","title":"Conclusion","text":"<p>F\u00e9licitations! \ud83c\udf89 Vous avez cr\u00e9\u00e9 une API Blog compl\u00e8te avec:</p> <p>\u2705 Authentification JWT (User, Login, Register) \u2705 Articles (CRUD complet avec slug, tags, publish/unpublish) \u2705 Commentaires (Create, List, Delete) \u2705 Relations (Post \u2192 Author, Comment \u2192 Post + Author) \u2705 Pagination (Limit/Offset) \u2705 Tests unitaires \u2705 D\u00e9ploiement Docker \u2705 Architecture hexagonale \u2705 Logging structur\u00e9 \u2705 Error handling centralis\u00e9</p>"},{"location":"tutorial-exemple-complet/#resume-de-ce-que-vous-avez-appris","title":"R\u00e9sum\u00e9 de ce que vous avez appris","text":"<ol> <li>Installation de create-go-starter</li> <li>G\u00e9n\u00e9ration d'un projet complet</li> <li>Configuration (.env, PostgreSQL, JWT)</li> <li>Architecture hexagonale:</li> <li>Domain (entities, services)</li> <li>Adapters (handlers, repositories)</li> <li>Interfaces (ports)</li> <li>Dependency Injection avec uber-go/fx</li> <li>GORM (migrations, queries, relations)</li> <li>Fiber (routes, middleware, handlers)</li> <li>Tests avec testify et mocks</li> <li>Docker et docker-compose</li> </ol>"},{"location":"tutorial-exemple-complet/#prochaines-etapes","title":"Prochaines \u00e9tapes","text":"<p>Pour aller plus loin:</p> <ul> <li>Upload d'images pour les articles</li> <li>Recherche full-text dans les posts</li> <li>Likes/Votes sur les articles</li> <li>Cat\u00e9gories pour organiser les posts</li> <li>Swagger pour documenter l'API</li> <li>CI/CD avec GitHub Actions</li> <li>Kubernetes pour d\u00e9ploiement en production</li> </ul>"},{"location":"tutorial-exemple-complet/#ressources","title":"Ressources","text":"<ul> <li>Guide des projets g\u00e9n\u00e9r\u00e9s - Documentation compl\u00e8te</li> <li>Repository exemple - Code complet</li> <li>Fiber documentation</li> <li>GORM documentation</li> </ul> <p>Bon coding! \ud83d\ude80</p>"},{"location":"usage/","title":"Guide d'utilisation","text":"<p>Ce guide d\u00e9taille l'utilisation de <code>create-go-starter</code> et explique en profondeur la structure des projets g\u00e9n\u00e9r\u00e9s.</p>"},{"location":"usage/#commande-de-base","title":"Commande de base","text":"<p>La syntaxe de base est tr\u00e8s simple:</p> <pre><code>create-go-starter &lt;nom-du-projet&gt;\n</code></pre>"},{"location":"usage/#exemple","title":"Exemple","text":"<pre><code>create-go-starter mon-api-backend\n</code></pre> <p>Cette commande va cr\u00e9er un nouveau r\u00e9pertoire <code>mon-api-backend/</code> avec toute la structure du projet.</p>"},{"location":"usage/#options-disponibles","title":"Options disponibles","text":""},{"location":"usage/#flags-actuels","title":"Flags actuels","text":"<pre><code>create-go-starter --help    # Afficher l'aide\ncreate-go-starter -h        # Alias pour --help\n</code></pre> <p>Note: D'autres options seront ajout\u00e9es dans les futures versions (choix de templates, bases de donn\u00e9es, frameworks, etc.)</p>"},{"location":"usage/#conventions-de-nommage","title":"Conventions de nommage","text":"<p>Le nom du projet doit respecter certaines r\u00e8gles:</p>"},{"location":"usage/#caracteres-autorises","title":"Caract\u00e8res autoris\u00e9s","text":"<ul> <li>Lettres: a-z, A-Z</li> <li>Chiffres: 0-9</li> <li>Tirets: - (hyphen)</li> <li>Underscores: _ (trait de soulignement)</li> </ul>"},{"location":"usage/#restrictions","title":"Restrictions","text":"<ul> <li>Pas d'espaces</li> <li>Pas de caract\u00e8res sp\u00e9ciaux (/, \\, @, #, etc.)</li> <li>Pas de points (.)</li> <li>Doit commencer par une lettre ou un chiffre (pas de tiret au d\u00e9but)</li> </ul>"},{"location":"usage/#exemples-valides","title":"Exemples valides","text":"<pre><code>create-go-starter mon-projet           \u2705\ncreate-go-starter my-awesome-api       \u2705\ncreate-go-starter user_service         \u2705\ncreate-go-starter app2024              \u2705\ncreate-go-starter MonProjet            \u2705\n</code></pre>"},{"location":"usage/#exemples-invalides","title":"Exemples invalides","text":"<pre><code>create-go-starter mon projet           \u274c (contient un espace)\ncreate-go-starter mon-projet!          \u274c (caract\u00e8re sp\u00e9cial)\ncreate-go-starter my.project           \u274c (contient un point)\ncreate-go-starter -mon-projet          \u274c (commence par un tiret)\ncreate-go-starter mon/projet           \u274c (contient un slash)\n</code></pre>"},{"location":"usage/#structure-generee","title":"Structure g\u00e9n\u00e9r\u00e9e","text":"<p>Voici la structure compl\u00e8te cr\u00e9\u00e9e par <code>create-go-starter</code>:</p> <pre><code>mon-projet/\n\u251c\u2500\u2500 cmd/\n\u2502   \u2514\u2500\u2500 main.go                              # Point d'entr\u00e9e de l'application\n\u2502\n\u251c\u2500\u2500 internal/\n\u2502   \u251c\u2500\u2500 models/\n\u2502   \u2502   \u2514\u2500\u2500 user.go                          # Entit\u00e9s partag\u00e9es: User, RefreshToken, AuthResponse\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 adapters/\n\u2502   \u2502   \u251c\u2500\u2500 handlers/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 auth_handler.go              # Endpoints auth (register, login, refresh)\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 auth_handler_test.go         # Tests handlers auth\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 user_handler.go              # Endpoints CRUD users\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 user_handler_test.go         # Tests handlers users\n\u2502   \u2502   \u251c\u2500\u2500 middleware/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 auth_middleware.go           # Middleware JWT authentication\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 auth_middleware_test.go      # Tests middleware auth\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 error_handler.go             # Middleware gestion centralis\u00e9e erreurs\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 error_handler_test.go        # Tests error handler\n\u2502   \u2502   \u251c\u2500\u2500 repository/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 user_repository.go           # Impl\u00e9mentation GORM du repository\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 user_repository_test.go      # Tests repository\n\u2502   \u2502   \u2514\u2500\u2500 http/\n\u2502   \u2502       \u251c\u2500\u2500 health.go                    # Handler health check\n\u2502   \u2502       \u251c\u2500\u2500 health_test.go               # Tests health check\n\u2502   \u2502       \u2514\u2500\u2500 routes.go                    # Routes centralis\u00e9es de l'API\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 domain/\n\u2502   \u2502   \u251c\u2500\u2500 errors.go                        # Erreurs m\u00e9tier personnalis\u00e9es\n\u2502   \u2502   \u251c\u2500\u2500 errors_test.go                   # Tests erreurs\n\u2502   \u2502   \u2514\u2500\u2500 user/\n\u2502   \u2502       \u251c\u2500\u2500 service.go                   # Logique m\u00e9tier (Register, Login, etc.)\n\u2502   \u2502       \u251c\u2500\u2500 service_test.go              # Tests service\n\u2502   \u2502       \u2514\u2500\u2500 module.go                    # Module fx pour dependency injection\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 infrastructure/\n\u2502   \u2502   \u251c\u2500\u2500 database/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 database.go                  # Configuration GORM et connexion DB\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 database_test.go             # Tests database\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 module.go                    # Module fx pour database\n\u2502   \u2502   \u2514\u2500\u2500 server/\n\u2502   \u2502       \u251c\u2500\u2500 server.go                    # Configuration Fiber app\n\u2502   \u2502       \u251c\u2500\u2500 server_test.go               # Tests server\n\u2502   \u2502       \u2514\u2500\u2500 module.go                    # Module fx pour server\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 interfaces/\n\u2502       \u251c\u2500\u2500 auth_service.go                  # Interface AuthService (port)\n\u2502       \u251c\u2500\u2500 user_service.go                  # Interface UserService (port)\n\u2502       \u2514\u2500\u2500 user_repository.go               # Interface UserRepository (port)\n\u2502\n\u251c\u2500\u2500 pkg/\n\u2502   \u251c\u2500\u2500 auth/\n\u2502   \u2502   \u251c\u2500\u2500 jwt.go                           # G\u00e9n\u00e9ration et parsing JWT tokens\n\u2502   \u2502   \u251c\u2500\u2500 jwt_test.go                      # Tests JWT\n\u2502   \u2502   \u251c\u2500\u2500 middleware.go                    # Middleware JWT pour Fiber\n\u2502   \u2502   \u251c\u2500\u2500 middleware_test.go               # Tests middleware\n\u2502   \u2502   \u2514\u2500\u2500 module.go                        # Module fx pour auth\n\u2502   \u251c\u2500\u2500 config/\n\u2502   \u2502   \u251c\u2500\u2500 env.go                           # Chargement variables d'environnement\n\u2502   \u2502   \u251c\u2500\u2500 env_test.go                      # Tests config\n\u2502   \u2502   \u2514\u2500\u2500 module.go                        # Module fx pour config\n\u2502   \u2514\u2500\u2500 logger/\n\u2502       \u251c\u2500\u2500 logger.go                        # Configuration zerolog\n\u2502       \u251c\u2500\u2500 logger_test.go                   # Tests logger\n\u2502       \u2514\u2500\u2500 module.go                        # Module fx pour logger\n\u2502\n\u251c\u2500\u2500 .github/\n\u2502   \u2514\u2500\u2500 workflows/\n\u2502       \u2514\u2500\u2500 ci.yml                           # Pipeline CI/CD GitHub Actions\n\u2502\n\u251c\u2500\u2500 .env                                     # Variables d'environnement (cr\u00e9\u00e9 automatiquement)\n\u251c\u2500\u2500 .env.example                             # Template de configuration\n\u251c\u2500\u2500 .gitignore                               # Exclusions Git\n\u251c\u2500\u2500 .golangci.yml                            # Configuration golangci-lint\n\u251c\u2500\u2500 Dockerfile                               # Build Docker multi-stage\n\u251c\u2500\u2500 Makefile                                 # Commandes utiles (run, test, lint, etc.)\n\u251c\u2500\u2500 setup.sh                                 # Script de configuration automatique\n\u251c\u2500\u2500 go.mod                                   # Module Go et d\u00e9pendances\n\u2514\u2500\u2500 README.md                                # Documentation du projet\n</code></pre> <p>Total: ~45+ fichiers cr\u00e9\u00e9s automatiquement!</p>"},{"location":"usage/#explication-detaillee-de-chaque-repertoire","title":"Explication d\u00e9taill\u00e9e de chaque r\u00e9pertoire","text":""},{"location":"usage/#cmd","title":"<code>/cmd</code>","text":"<p>R\u00f4le: Point d'entr\u00e9e de l'application.</p> <p>Contenu: - <code>main.go</code>: Bootstrap de l'application avec uber-go/fx   - Initialise tous les modules (database, server, logger, etc.)   - Configure le lifecycle (OnStart, OnStop)   - Lance l'application avec <code>fx.New().Run()</code></p> <p>Pattern: Un seul fichier minimal qui orchestre les d\u00e9pendances.</p>"},{"location":"usage/#internalmodels","title":"<code>/internal/models</code>","text":"<p>R\u00f4le: Entit\u00e9s de domaine partag\u00e9es (domain entities) utilis\u00e9es \u00e0 travers toute l'application.</p> <p>Contenu: - <code>user.go</code>: D\u00e9finit toutes les entit\u00e9s li\u00e9es aux utilisateurs   - <code>User</code>: Entit\u00e9 principale avec tags GORM (ID, Email, PasswordHash, timestamps)   - <code>RefreshToken</code>: Entit\u00e9 pour la gestion des refresh tokens JWT   - <code>AuthResponse</code>: DTO pour les r\u00e9ponses d'authentification</p> <p>Pourquoi un package s\u00e9par\u00e9? - \u00c9vite les d\u00e9pendances circulaires: Avant, <code>interfaces</code> \u2192 <code>domain/user</code> \u2192 <code>interfaces</code> cr\u00e9ait un cycle - Maintenant: <code>interfaces</code> \u2192 <code>models</code> \u2190 <code>domain/user</code> (pas de cycle!) - Centralisation: Les entit\u00e9s sont d\u00e9finies en un seul endroit - R\u00e9utilisabilit\u00e9: Tous les layers (domain, interfaces, adapters) peuvent importer models sans conflit</p> <p>Import: <pre><code>import \"mon-projet/internal/models\"\n\nuser := &amp;models.User{\n    Email: \"user@example.com\",\n    PasswordHash: hashedPassword,\n}\n</code></pre></p>"},{"location":"usage/#internaldomain","title":"<code>/internal/domain</code>","text":"<p>R\u00f4le: Couche m\u00e9tier (logique business), c\u0153ur de l'architecture hexagonale.</p> <p>Contenu: - <code>errors.go</code>: D\u00e9finition des erreurs m\u00e9tier (DomainError, NotFoundError, ValidationError, etc.) - <code>user/</code>: Domaine User   - <code>service.go</code>: Logique m\u00e9tier (Register, Login, GetUserByID, UpdateUser, DeleteUser)   - <code>module.go</code>: Module fx qui fournit le service</p> <p>Principe: Le domaine ne doit jamais importer d'autres packages (adapters, infrastructure). Les d\u00e9pendances sont invers\u00e9es via interfaces (ports). Les entit\u00e9s sont maintenant dans <code>internal/models</code> pour \u00e9viter les cycles de d\u00e9pendances.</p>"},{"location":"usage/#internaladapters","title":"<code>/internal/adapters</code>","text":"<p>R\u00f4le: Adaptateurs qui connectent le domaine au monde ext\u00e9rieur (HTTP, DB).</p>"},{"location":"usage/#internaladaptershandlers","title":"<code>/internal/adapters/handlers</code>","text":"<p>R\u00f4le: Handlers HTTP qui exposent l'API REST.</p> <p>Contenu: - <code>auth_handler.go</code>:   - <code>Register</code>: POST /api/v1/auth/register   - <code>Login</code>: POST /api/v1/auth/login   - <code>RefreshToken</code>: POST /api/v1/auth/refresh - <code>user_handler.go</code>:   - <code>List</code>: GET /api/v1/users   - <code>GetByID</code>: GET /api/v1/users/:id   - <code>Update</code>: PUT /api/v1/users/:id   - <code>Delete</code>: DELETE /api/v1/users/:id</p> <p>Pattern: Handlers parsent les requ\u00eates, valident, appellent les services du domaine, retournent les r\u00e9ponses.</p>"},{"location":"usage/#internaladaptersmiddleware","title":"<code>/internal/adapters/middleware</code>","text":"<p>R\u00f4le: Middleware Fiber pour cross-cutting concerns.</p> <p>Contenu: - <code>auth_middleware.go</code>: V\u00e9rifie le JWT token dans les requ\u00eates - <code>error_handler.go</code>: Gestion centralis\u00e9e des erreurs (convertit DomainError en r\u00e9ponses HTTP)</p>"},{"location":"usage/#internaladaptersrepository","title":"<code>/internal/adapters/repository</code>","text":"<p>R\u00f4le: Impl\u00e9mentation du pattern Repository avec GORM.</p> <p>Contenu: - <code>user_repository.go</code>: Impl\u00e9mentation de l'interface UserRepository   - Create, FindByID, FindByEmail, Update, Delete   - Utilise GORM pour les op\u00e9rations DB</p> <p>Pattern: Repository isole le domaine de la couche de persistance.</p>"},{"location":"usage/#internaladaptershttp","title":"<code>/internal/adapters/http</code>","text":"<p>R\u00f4le: Routes HTTP et handlers utilitaires.</p> <p>Contenu: - <code>health.go</code>: Endpoint GET /health pour monitoring - <code>routes.go</code>: Configuration centralis\u00e9e de toutes les routes de l'API</p> <p>Avantages de la centralisation des routes: - Vue d'ensemble de toutes les routes en un seul fichier - Facilite la documentation et le versioning de l'API - S\u00e9paration claire entre d\u00e9finition des routes et logique des handlers</p>"},{"location":"usage/#internalinfrastructure","title":"<code>/internal/infrastructure</code>","text":"<p>R\u00f4le: Configuration de l'infrastructure (DB, serveur).</p>"},{"location":"usage/#internalinfrastructuredatabase","title":"<code>/internal/infrastructure/database</code>","text":"<p>R\u00f4le: Configuration et connexion \u00e0 la base de donn\u00e9es.</p> <p>Contenu: - <code>database.go</code>:   - Connexion PostgreSQL via GORM   - Configuration du pool de connexions   - AutoMigrate des entit\u00e9s (<code>models.User</code>, <code>models.RefreshToken</code>)   - Gestion du lifecycle (fermeture connexion)</p>"},{"location":"usage/#internalinfrastructureserver","title":"<code>/internal/infrastructure/server</code>","text":"<p>R\u00f4le: Configuration du serveur HTTP Fiber.</p> <p>Contenu: - <code>server.go</code>:   - Configuration Fiber app   - Middleware error handler   - Lifecycle du serveur (start, graceful shutdown)   - Note: Les routes sont enregistr\u00e9es via <code>server.Module</code> qui invoque <code>httpRoutes.RegisterRoutes()</code> avec <code>fx.Invoke</code></p>"},{"location":"usage/#internalinterfaces","title":"<code>/internal/interfaces</code>","text":"<p>R\u00f4le: D\u00e9finition des ports (interfaces) pour l'architecture hexagonale.</p> <p>Contenu: - <code>user_repository.go</code>: Interface pour la persistance utilisateur</p> <p>Principe: - Les adapters d\u00e9pendent de ces interfaces, pas des impl\u00e9mentations concr\u00e8tes - Les interfaces r\u00e9f\u00e9rencent <code>models.*</code> pour les types de retour/param\u00e8tres - Exemple: <code>CreateUser(ctx context.Context, user *models.User) error</code></p>"},{"location":"usage/#pkg","title":"<code>/pkg</code>","text":"<p>R\u00f4le: Packages r\u00e9utilisables, peuvent \u00eatre import\u00e9s par d'autres projets.</p>"},{"location":"usage/#pkgauth","title":"<code>/pkg/auth</code>","text":"<p>R\u00f4le: Utilitaires JWT.</p> <p>Contenu: - <code>jwt.go</code>: G\u00e9n\u00e9ration et validation de tokens JWT   - GenerateAccessToken (15min)   - GenerateRefreshToken (7 jours)   - ParseToken - <code>middleware.go</code>: Middleware Fiber pour JWT</p>"},{"location":"usage/#pkgconfig","title":"<code>/pkg/config</code>","text":"<p>R\u00f4le: Chargement de la configuration.</p> <p>Contenu: - <code>env.go</code>: Charge les variables .env (godotenv) et les expose via struct Config</p>"},{"location":"usage/#pkglogger","title":"<code>/pkg/logger</code>","text":"<p>R\u00f4le: Configuration du logger.</p> <p>Contenu: - <code>logger.go</code>: Configure zerolog (niveau, format, output)</p>"},{"location":"usage/#githubworkflows","title":"<code>/.github/workflows</code>","text":"<p>R\u00f4le: CI/CD avec GitHub Actions.</p> <p>Contenu: - <code>ci.yml</code>: Pipeline qui ex\u00e9cute:   1. golangci-lint (quality checks)   2. Tests avec PostgreSQL (service container)   3. Build verification</p>"},{"location":"usage/#fichiers-de-configuration-detailles","title":"Fichiers de configuration d\u00e9taill\u00e9s","text":""},{"location":"usage/#env-et-envexample","title":"<code>.env</code> et <code>.env.example</code>","text":"<p>Le fichier <code>.env.example</code> est un template, et <code>.env</code> est copi\u00e9 automatiquement lors de la g\u00e9n\u00e9ration.</p> <p>Variables:</p> <pre><code># Application\nAPP_NAME=mon-projet                # Nom de l'app (utilis\u00e9 dans logs)\nAPP_ENV=development                # Environnement (development, staging, production)\nAPP_PORT=8080                      # Port HTTP\n\n# Database PostgreSQL\nDB_HOST=localhost                  # H\u00f4te de la DB\nDB_PORT=5432                       # Port PostgreSQL\nDB_USER=postgres                   # Utilisateur DB\nDB_PASSWORD=postgres               # Mot de passe DB\nDB_NAME=mon-projet                 # Nom de la base de donn\u00e9es\nDB_SSLMODE=disable                 # SSL mode (require pour production)\n\n# JWT Authentication\nJWT_SECRET=                        # SECRET CRITIQUE - \u00c0 g\u00e9n\u00e9rer!\nJWT_EXPIRY=15m                     # Dur\u00e9e des access tokens (15 minutes)\nREFRESH_TOKEN_EXPIRY=168h          # Dur\u00e9e des refresh tokens (7 jours)\n</code></pre> <p>Important: G\u00e9n\u00e9rez un JWT_SECRET s\u00e9curis\u00e9:</p> <pre><code>openssl rand -base64 32\n</code></pre> <p>Puis ajoutez-le dans <code>.env</code>:</p> <pre><code>JWT_SECRET=votre_secret_genere_ici\n</code></pre>"},{"location":"usage/#gomod","title":"<code>go.mod</code>","text":"<p>D\u00e9finit le module Go et les d\u00e9pendances:</p> <pre><code>module mon-projet\n\ngo 1.25\n\nrequire (\n    github.com/gofiber/fiber/v2 v2.x.x\n    github.com/golang-jwt/jwt/v5 v5.x.x\n    gorm.io/gorm v1.x.x\n    gorm.io/driver/postgres v1.x.x\n    go.uber.org/fx v1.x.x\n    github.com/rs/zerolog v1.x.x\n    github.com/go-playground/validator/v10 v10.x.x\n    golang.org/x/crypto v0.x.x\n    github.com/joho/godotenv v1.x.x\n    // ... autres d\u00e9pendances\n)\n</code></pre>"},{"location":"usage/#makefile","title":"<code>Makefile</code>","text":"<p>Commandes utiles pour le d\u00e9veloppement:</p> <pre><code>.PHONY: help run build test test-coverage lint clean docker-build docker-run\n\nhelp:           # Afficher toutes les commandes\nrun:            # Lancer l'application (go run)\nbuild:          # Compiler le binaire\ntest:           # Ex\u00e9cuter les tests avec race detector\ntest-coverage:  # Tests avec rapport HTML de coverage\nlint:           # Linter avec golangci-lint\nclean:          # Nettoyer les artifacts\ndocker-build:   # Build l'image Docker\ndocker-run:     # Lancer le conteneur Docker\n</code></pre>"},{"location":"usage/#golangciyml","title":"<code>.golangci.yml</code>","text":"<p>Configuration du linter avec r\u00e8gles strictes:</p> <ul> <li>errcheck, gosimple, govet, ineffassign, staticcheck</li> <li>gofmt, goimports</li> <li>misspell, revive</li> <li>Exclusions pour tests et code g\u00e9n\u00e9r\u00e9</li> </ul>"},{"location":"usage/#dockerfile","title":"<code>Dockerfile</code>","text":"<p>Build multi-stage optimis\u00e9:</p> <p>Stage 1 (builder): - Image golang:1.25-alpine - Build du binaire statique</p> <p>Stage 2 (runtime): - Image alpine:latest (l\u00e9g\u00e8re) - Copie du binaire seulement - Ex\u00e9cution en tant que non-root - EXPOSE 8080</p> <p>Taille finale: ~15-20MB (vs ~1GB avec image golang compl\u00e8te)</p>"},{"location":"usage/#workflow-apres-generation","title":"Workflow apr\u00e8s g\u00e9n\u00e9ration","text":"<p>Une fois le projet cr\u00e9\u00e9, vous avez deux options pour configurer votre projet:</p>"},{"location":"usage/#option-a-configuration-automatique-avec-setupsh-recommande","title":"Option A: Configuration automatique avec setup.sh (Recommand\u00e9) \ud83d\ude80","text":"<p>Le CLI g\u00e9n\u00e8re automatiquement un script <code>setup.sh</code> qui automatise toute la configuration initiale.</p> <p>Fonctionnalit\u00e9s du script: - \u2705 V\u00e9rification des pr\u00e9requis (Go, OpenSSL, Docker) - \u2705 Installation des d\u00e9pendances Go (<code>go mod tidy</code>) - \u2705 G\u00e9n\u00e9ration automatique du JWT secret - \u2705 Configuration de PostgreSQL (Docker ou local) - \u2705 Ex\u00e9cution des tests - \u2705 V\u00e9rification de l'installation</p> <p>Utilisation:</p> <pre><code>cd mon-projet\n./setup.sh\n</code></pre> <p>Le script est interactif et vous guidera \u00e0 travers les choix: - Docker ou PostgreSQL local - R\u00e9g\u00e9n\u00e9ration du JWT secret si d\u00e9j\u00e0 configur\u00e9 - Validation \u00e0 chaque \u00e9tape</p> <p>Apr\u00e8s l'ex\u00e9cution du script:</p> <pre><code>make run\n</code></pre> <p>C'est tout! Votre application est pr\u00eate.</p>"},{"location":"usage/#option-b-configuration-manuelle","title":"Option B: Configuration manuelle","text":"<p>Si vous pr\u00e9f\u00e9rez configurer manuellement ou si le script setup.sh \u00e9choue, suivez ces \u00e9tapes:</p>"},{"location":"usage/#etape-1-naviguer-dans-le-projet","title":"\u00c9tape 1: Naviguer dans le projet","text":"<pre><code>cd mon-projet\n</code></pre>"},{"location":"usage/#etape-2-configurer-les-variables-denvironnement","title":"\u00c9tape 2: Configurer les variables d'environnement","text":"<pre><code># G\u00e9n\u00e9rer un JWT secret\nopenssl rand -base64 32\n\n# \u00c9diter .env et ajouter le secret\nnano .env  # ou vim, code, etc.\n</code></pre> <p>Ajoutez: <pre><code>JWT_SECRET=le_secret_genere\n</code></pre></p>"},{"location":"usage/#etape-3-installer-les-dependances","title":"\u00c9tape 3: Installer les d\u00e9pendances","text":"<pre><code>go mod tidy\n</code></pre>"},{"location":"usage/#etape-4-lancer-postgresql","title":"\u00c9tape 4: Lancer PostgreSQL","text":"<p>Option A: Docker (recommand\u00e9)</p> <pre><code>docker run -d \\\n  --name postgres \\\n  -e POSTGRES_DB=mon-projet \\\n  -e POSTGRES_PASSWORD=postgres \\\n  -p 5432:5432 \\\n  postgres:16-alpine\n</code></pre> <p>Option B: Installation locale</p> <pre><code># macOS\nbrew install postgresql\nbrew services start postgresql\ncreatedb mon-projet\n\n# Linux\nsudo apt install postgresql\nsudo systemctl start postgresql\nsudo -u postgres createdb mon-projet\n</code></pre>"},{"location":"usage/#etape-5-lancer-lapplication","title":"\u00c9tape 5: Lancer l'application","text":"<pre><code>make run\n</code></pre> <p>Ou directement:</p> <pre><code>go run cmd/main.go\n</code></pre> <p>Vous devriez voir:</p> <pre><code>{\"level\":\"info\",\"time\":\"...\",\"message\":\"Starting server on :8080\"}\n{\"level\":\"info\",\"time\":\"...\",\"message\":\"Database connected successfully\"}\n</code></pre>"},{"location":"usage/#etape-6-tester-lapi","title":"\u00c9tape 6: Tester l'API","text":"<pre><code># Health check\ncurl http://localhost:8080/health\n# {\"status\":\"ok\"}\n\n# Register un utilisateur\ncurl -X POST http://localhost:8080/api/v1/auth/register \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"email\":\"test@example.com\",\"password\":\"password123\"}'\n\n# Login\ncurl -X POST http://localhost:8080/api/v1/auth/login \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"email\":\"test@example.com\",\"password\":\"password123\"}'\n</code></pre>"},{"location":"usage/#commandes-make-disponibles","title":"Commandes Make disponibles","text":"<p>Le Makefile g\u00e9n\u00e9r\u00e9 inclut ces commandes:</p> Commande Description Usage <code>make help</code> Afficher l'aide Voir toutes les commandes <code>make run</code> Lancer l'app D\u00e9veloppement local <code>make build</code> Compiler le binaire Cr\u00e9er l'ex\u00e9cutable <code>make test</code> Tests avec race detector V\u00e9rifier le code <code>make test-coverage</code> Tests + rapport HTML Voir le coverage <code>make lint</code> golangci-lint V\u00e9rifier la qualit\u00e9 <code>make clean</code> Nettoyer Supprimer artifacts <code>make docker-build</code> Build image Docker Containerisation <code>make docker-run</code> Lancer conteneur Test Docker <p>Exemples:</p> <pre><code># D\u00e9veloppement quotidien\nmake run          # Lance l'app avec hot-reload (si air install\u00e9)\n\n# Avant commit\nmake test         # V\u00e9rifie que tous les tests passent\nmake lint         # V\u00e9rifie la qualit\u00e9 du code\n\n# Build pour production\nmake build        # Cr\u00e9e le binaire\n./mon-projet      # Ex\u00e9cute le binaire\n\n# Docker\nmake docker-build # Build l'image\nmake docker-run   # Teste le conteneur\n</code></pre>"},{"location":"usage/#prochaines-etapes","title":"Prochaines \u00e9tapes","text":"<p>Maintenant que vous comprenez la structure, consultez:</p> <ol> <li>Guide des projets g\u00e9n\u00e9r\u00e9s - Guide complet pour:</li> <li>Comprendre l'architecture hexagonale</li> <li>D\u00e9velopper de nouvelles fonctionnalit\u00e9s</li> <li>Utiliser l'API (endpoints, authentification)</li> <li>\u00c9crire des tests</li> <li> <p>D\u00e9ployer en production</p> </li> <li> <p>Architecture du CLI - Si vous voulez:</p> </li> <li>Comprendre comment fonctionne le g\u00e9n\u00e9rateur</li> <li>Contribuer au projet</li> <li> <p>\u00c9tendre les templates</p> </li> <li> <p>Commencer \u00e0 d\u00e9velopper:    <pre><code># Lancer l'app\nmake run\n\n# Dans un autre terminal, tester l'API\ncurl http://localhost:8080/health\n\n# Lire le code g\u00e9n\u00e9r\u00e9\ncat internal/domain/user/service.go\ncat internal/adapters/handlers/auth_handler.go\n</code></pre></p> </li> </ol>"},{"location":"usage/#conseils","title":"Conseils","text":"<ul> <li>Lisez le code g\u00e9n\u00e9r\u00e9: Chaque fichier est un exemple de best practice Go</li> <li>Modifiez selon vos besoins: La structure est un point de d\u00e9part, adaptez-la</li> <li>Suivez les patterns: Repository, dependency injection, error handling centralis\u00e9</li> <li>Testez r\u00e9guli\u00e8rement: <code>make test</code> avant chaque commit</li> <li>Utilisez le linter: <code>make lint</code> pour maintenir la qualit\u00e9</li> </ul> <p>Bon d\u00e9veloppement! \ud83d\ude80</p>"}]}